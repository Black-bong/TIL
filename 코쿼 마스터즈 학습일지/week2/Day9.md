# 객체지향 설계와 프로그래밍

## 절차지향 vs 객체지향

## 절차지향
- 대표적인 언어: C
- 장점
  - 처음 배우기가 쉽다.
  - 컴퓨터의 처리구조와 유사하여 속도가 빠르다.
- 단점
  - 모든 구성요소가 유기적으로 연결되어 있어, 유지보수가 매우 까다롭다.
  - 언어의 융통성이 부족해서 생산성 효율이 떨어진다. (실행 순서가 엄격하게 정해져 있다.)
## 객체지향
- 대표적인 언어: JAVA
- 장점
  - 유지보수가 쉽다.
  - 코드의 재활용이 가능하다.
- 단점
  - 객체지향의 개념을 이해하고 배우는데 시간이 많이 걸린다(어렵다.)
  - 설계에 많은 시간이 소요된다.

### 객체지향의 4가지 특징
1. 추상화: 필요로 하는 속성이나 행동을 추출하는 작업
   - 세부적인 사물들의 공통적인 특징을 파악한 후 하나의 집합으로 만들어내는 것
   - 추상적인 개념에 의존하여 설계해야 유연함을 갖출 수 있다.
2. 캡슐화: 낮은 결합도를 유지할 수 있도록 설계하는 것
   - 독립적으로 만들어진 객체들 간의 의존도를 최대한 낮게 만드는 것이 중요하다.
   - 의존도가 높을수록 하나의 변화가 여러곳에 영향을 줄 수 있기 때문에 이럴경우 변경이 어려워져 유연성이 떨어지게 된다.
3. 상속: 일반화 관계라고도 하며, 여러 개체들이 지닌 공통된 특성을 부각시켜 하나의 개념이나 법칙으로 성립하는 과정
   - 자식 클래스를 외부로부터 은닉하는 캡슐화의 일종
4. 다형성: 서로 다른 클래스의 객체가 같은 메시지를 받았을 때 각자의 방식으로 동작하는 능력
   - 객체지향의 핵심
   - 부모 클래스의 메소드를 자식 클래스가 오버라이딩해서 자신의 역할에 맞게 활용하는 것

### 상속 재사용의 단점
1. 상위 클래스의 변경이 어려워진다.
   - 상위 클래스의 변경이 하위 클래스에 영향을 주기 때문에 하위 클래스가 많을 경우 상위 클래스의 변경이 어려워진다.
2. 불필요한 클래스가 증가할 수 있다. 
   - 유사 기능을 확장할떄 필요 이상의 불필요한 클래스를 만들어야 하는 상황이 발생할 수 있다.
3. 상속이 잘못 사용될 수 있다.
   - 같은 종류가 아닌 클래스의 구현을 재사용하기 위해 상속을 받게 되면, 문제가 발생할 수 있다.
- is-a관계와 has-a관계
  - is-a관계: 추상화한 클래스간의 포함 관계를 의미하며, 한 클래스 A가 다른 클래스 B의 서브 클래스임을 이야기한다.
  - has-a관계: 구성관계를 의미하며, 한 오브젝트가 다른 오브젝트에 속한다를 말한다.
- 해결책은?
  - 상속(inheritance)보단 조립(composition)
  - 조립
    - 여러 객체를 묶어서 더 복잡한 기능을 제공
    - 보통 필드로 다른 객체를 참조하는 방식으로 조립 또는 객체를 필요 시점에 생성
- 상속의 사용 시기
  - 상속하기에 앞서 조립으로 풀 수 없는지 검토
  - is-a관계가 성립할때
  - 재사용의 관점이 아닌, 기능 확정의 관점일때 

### 객체지향 설계 과정
- 제공해야 할 기능을 찾고 세분화한다. 그리고 그 기능을 알맞은 객체에 할당한다.
- 기능을 구현하는데 필요한 데이터를 객체에 추가한다.
- 그 데이터를 이용하는 기능을 넣는다.
- 기능을 최대한 캡슐화하여 구현한다.
- 객체 간에 어떻게 메소드 요청을 주고 받을 지 결정한다.

### 객체지향의 5가지 설계원칙(SOLID설계 원칙)
1. SRP(Single Responsibility): 단일 책임 원칙
   - 클래스는 단 하나의 책임만을 가져야한다.
   - 클래스를 변경하는 이유는 단 한개여야 한다.
2. OCP(Open-Closed): 개방-폐쇄 원칙
   - 확장에는 열려있고, 변경에는 닫혀 있어야한다.
   - 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다.
3. LSP(Liskov Substitution): 리스코프 치환 원칙
   - 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
   - is-a 관계가 아닌 클래스들을 상속 관계로 설정하면, LSP원칙에 위배
4. ISP(Interface Segregation): 인터페이스 분리 원칙
   - 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
   - 클라이언트가 사용하지 않는 인터페이스의 변경에 클라이언트가 영향을 받으면 안된다.
5. DIP(Dependency inversion): 의존 역전 원칙
   - 고수준 모듈은 저수준 묘듈의 구현에 의존해서는 안된다.
   - 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.  

## 캐스팅

### 캐스팅이란?
- 변수가 원하는 정보를 다 갖고 있는 것
- 타입을 변환하는 것을 말하며 형변환이라고도 한다.

### 캐스팅이 필요한 이유?
- 다형성: 오버라이딩된 함수를 분리해서 활용할 수 있다.
- 상속: 캐스팅을 통해 범용적인 프로그래밍이 가능하다.

### 형변환의 종료
- 묵시적 형변환: 캐스팅이 자동으로 발생
```java
Person p = new Student();
```
- 업 캐스팅
- 명시적 형변환: 캐스팅할 내용을 적어줘야 하는 경우
```java
Person p = new Student();
Student s = (Student) p;
```
- 다운 캐스팅
- 다운 캐스팅은 업 캐스팅이 발생한 이후 작용한다.

---
# reference
- <a href = "https://minusi.tistory.com/entry/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5%EC%A0%81-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C%EC%9D%98-has-a%EC%99%80-is-a-%EC%B0%A8%EC%9D%B4%EC%A0%90">객체 지향적 관점에서의 has-a와 is-a 차이점</a>
- <a href = "https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8/lecture/13435?tab=curriculum&volume=1.00&quality=1080&speed=1">객체 지향 프로그래밍 입문</a>
- <a href = "https://gyoogle.dev/blog/computer-science/software-engineering/Object-Oriented%20Programming.html">객체 지향 프로그래밍</a>