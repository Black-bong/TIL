# 마스터즈 코스 시작!(한달간의 CS10)
> 교장선생님(호눅스)의 훈화 말씀
> 
>>CS10을 대하는 자세
>>
>> 1.CS학습의 필요성을 느끼게 해주려고 만든 과정
>>
>> 2.필수: 자료구조 데이터베이스 운영체제 네트워크
>>
>> 3.옵션: 컴구조 시스템 프로그래밍 리눅스
>>
>> 4.포기는 ㄴㄴ, 요것만 끝나면 재미있다!
>>
>> 5.자바 프로그래밍 많이 하자

## CS10 소개

### 어떻게 공부해야하나
- 양이 너무 많다. 6개월동안 이것만 해도 시간이 부족
- 키워드를 바탕으로 학습하는 대신 비슷한 주제의 키워드를 연계해서 공부
- 학습한 내용을 자기만의 표현으로 이해하고 설명하는 연습이 필요하다.
- 분야마다 필요한 지식이 있을 수 있으나, 필요없다 해서 중요하지 않은 지식은 아니다.
- 학습하는 방법을 학습하는 시간으로..

### 사실과 오해
- 이론뿐 아니라 어떻게 사용하는지도 공부
- 학습과 구현의 밸런스..(코코아때도 이 균형을 잡는게 너무 어려웠는데)
- 하나의 문제를 해결하더라도 충분히 학습해보고 구현
- 구현만! 학습만! 안된다.
- 한 권으로 읽는 컴구조와 프로그래밍 책 추천!!
- 아는건 더 명확하게(다른사람에게 설명할 수 있나) 모르는건 철저하게

### 미션
- 정해져있지 않은 건 유추해서 구현
- secret gist로 제출(아이고...)

### 좋은주석
- 코드에 없는 정보를 설명할 때 쓰는 주석
- 나쁜 주석: add메서드에 덧셈하는 기능 등등 코드로 알 수 있는 걸 주석으로 써 놓은것

## 논리회로

### 논리 게이트

| A | B | A and B | A or B | !A |
| --- | --- | --- | --- | --- |
| TRUE | TRUE | TRUE | TRUE | FALSE |
| TRUE | FALSE | FALSE | TRUE | FALSE |
| FALSE | TRUE | FALSE | TRUE | TRUE |
| FALSE | FALSE | FALSE | FALSE | TURE |

- OR 게이트: 두개의 입력중 하나라도 `TRUE`면 `TRUE` 출력
- AND 게이트: 두개의 입력중 하나라도 `FALSE`면 `FALSE` 출력
- INVERTOR(NOT): 입력의 반대 출력

### 확장 게이트

| A | B | A ^ B (XOR) | NAND | NOR |
| --- | --- | --- | --- | --- |
| TRUE | TRUE | FALSE | FALSE | FALSE |
| TRUE | FALSE | TRUE | TRUE | FALSE |
| FALSE | TRUE | TRUE | TRUE | FALSE |
| FALSE | FALSE | FALSE | TRUE | TRUE |

- XOR 게이트: 두개의 입력이 서로 다를때 `TRUE` 출력
- NAND 게이트: !AND
- NOR 게이트: !OR

## 반가산기와 전가산기

### 반가산기란?
- 2개의 비트(입력 2개)만 계산할 수 있는 가산기
- 진리표
    | A(bit) | B(bit) | C(carry) | S(sum) |
    | --- | --- | --- | --- |
    | 0 | 0 | 0 | 0 |
    | 0 | 1 | 0 | 1 |
    | 1 | 0 | 0 | 1 |
    | 1 | 1 | 1 | 0 |
- A, B: 입력
- C, S: 출력
- S(sum): XOR 진리표와 동일
- C(carry): AND 진리표와 동일

### 전가사기란?
- 2개의 비트와 1개의 캐리(입력 3개)를 계산할 수 있는 가산기
- 2개의 반가산기와 1개의 OR게이트의 조합
- 진리표
    | X(bit) | Y(bit) | Z(carry) | C(carry) | S(sum) |
    | --- | --- | --- | --- | --- |
    | 0 | 0 | 0 | 0 | 0 |
    | 0 | 0 | 1 | 0 | 1 |
    | 0 | 1 | 0 | 0 | 1 |
    | 0 | 1 | 1 | 1 | 0 |
    | 1 | 0 | 0 | 0 | 1 |
    | 1 | 0 | 1 | 1 | 0 |
    | 1 | 1 | 0 | 1 | 0 |
    | 1 | 1 | 1 | 1 | 1 |
- X, Y, Z: 입력
- C, S: 출력
- S(sum): (X XOR Y) XOR Z
- C(carry): (X XOR Y)Z + XY

## 진법변환

### 2진수 -> 8, 16진수
- 8진수: 2진수 수를 소수점 기준으로 좌우로 3자리씩 끊어서 계산 남은 자리는 0으로 채운다.
  - 11111.11111(2): 011/111.111/110
    - 011: 3
    - 111: 7
    - 110: 6
    - 37.76(8)
- 16진수: 2진수 수를 소수점 기준으로 좌우로 4자리씩 끊어서 계산 남은 자리는 0으로 채운다.
  - 11111.11111(2): 0001/1111.1111/1000
    - 0001: 1
    - 1111: 15(F)
    - 1000: 8
    - 1F.F8(16)

## 큰 비트를 좌측에 배치하는 것과 우측에 배치하는 방식의 구현 차이

### 비트(bit)
- 컴퓨터가 데이터를 처리하기 위해 사용하는 데이터의 최소 단위.
- 비트에는 2진수의 값(0 또는 1)을 단 하나만 저장가능

### 바이트(byte)
- 8개의 비트가 모여 구성
- 한 문자를 표현할 수 있는 최소단위

### 바이트 저장 순서(byte order)
- 바이트를 배열하는 방법
- 빅 엔디안, 리틀 엔디안, 미들 엔디안 이있다.

### 빅 엔디안(big endian)
- 큰 단위가 앞에 나오는것
- 낮은 주소에 데이터의 높은 바이트(MSB, Most Significant Bit)부터 저장하는 방식
- 타입을 읽거나 형변환 하는데 빠르다.

### 리틀 엔디안(little endian)
- 작은 단위가 앞에 나오는것
- 낮은 주세에 데이터의 낮은 바이트(LSB, Least Significant Bit)부터 저장하는 방식
- 우리가 실질적으로 계산하는 방식과 동일

### 미들 엔디안(middle endian)
- 빅, 리틀 둘다 아니거나 둘다 지원하는 경우

### 빅 엔디안 vs 리틀 엔디안
- 저장해야 할 큰 데이터를 어떻게 나누어 저장하는가에 따른 차이
- 둘 다 데이터는 낮은 주소에서 높은 주소 순으로 저장
- 물리적으로 데이터를 조작하거나 산술 연산을 수행할 때는 리틀 엔디안 방식이 효율적
- 데이터의 각 바이트를 배열처럼 취급할 때에는 빅 엔디안 방식이 더 적합
- 네트워크 바이트 오더는 빅 엔디안을 사용

## 1일차 회고
- 오늘 학습: 전가산기, 반가산기, 바이트 저장순서
- 오늘 구현: 논리 게이트를 활용하는 가산기(전, 반, 바이트)를 구현
- 내일 할일: 진법 변환 구현하기

### 느낀점
- 첫날부터 미션이 어질어질하다..