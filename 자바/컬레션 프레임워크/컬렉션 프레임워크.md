# 컬렉션 프레임워크

---

> 유튜브에서 남궁성님의 자바의 정석강의를 보고 요약, 정리한 글입니다.
>
> `강의 내용외에 직접 검색하고, 찾아본 내용도 함께 작성될 수 있습니다.`
>
> > 출처: <a href = "https://www.youtube.com/watch?v=z9GpUGoYCw4&list=PLW2UjW795-f6xWA2_MUhEVgPauhGl3xIp&index=119" >컬렉션 프레임 웍과 핵심 인터페이스</a>
> >

---

## 컬렉션 프레임웍(collections framework)이란?
- 컬렉션을 다루기 위한 표준화된 프로그래밍 방식
- 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공

### 컬렉션(collection)
- 여러 객체(데이터)를 모아 놓은 것을 의미

### 프레임웍(framework)
- 표준화 정형화된 체계적인 프로그래밍 방식
- 라이브러리 + 프로그래밍 방식
  - 라이브러리에 비해 자유도는 떨어지지만, 방식이 정해져있어 유지보수가 쉽고 생산성이 높아진다.

### 컬렉션 클래스
- 다수의 데이터를 저장할 수 있는 클래스(예: Vector, ArrayList, HashSet)

### 컬렉션 프레임웍의 핵심 인터페이스

| 인터페이스 | 특징 | 구현 클래스 |
| --- | --- | --- |
| List | 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다. | ArrayList, LinkedList, Stack, Vector 등 |
| Set | 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다. | HashSet, TreeSet 등 |
| Map | 키(key)와 값(value)의 쌍으로 이루어진 데이터의 집합 순서는 유지되지 않으며, 키는 중복을 혀용하지 않고, 값은 중복을 허용한다. | HashMap, TreeMap, Hashtable, Properties 등 |

- List: 저장(중복을 허용하고, 순서가 유지된다.)
- Set: 집합(중복을 허용하지 않으며, 순서를 유지하지 않는다.)
- Map: 키, 값을 사용
- `List`와 `Set`의 공통부분을 뽑아내서 `Collection`이라는 인터페이스를 따로 정의했다.
- 다루는 데이터의 특성에 맞게 선택해서 사용

## Collection인터페이스의 메서드

| 메서드 | 설명 |
| --- | --- |
| boolean add(Object o)  boolean addAll(Collection c) | 지정된 객체 또는 Collection의 객체들을 Collection에 추가한다. |
| void clear() | Collection의 모든 객체를 삭제한다. |
| boolean contains(Object o)  boolean containsAll(Collection c) | 지정된 객체 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인한다. |
| boolean equals(Object o) | 동일한 Collection인지 비교한다. |
| int hasCode() | Collection의 hash code를 반환한다. |
| boolean isEmpty() | Collection이 비어있는지 확인한다. |
| Iterator iterator() | Collection의 iterator를 얻어서 반환한다. |
| boolean remove(Object o) | 지정된 객체를 삭제한다. |
| boolean removeAll(Collection c) | 지정된 Collection에 포함된 객체들을 삭제한다. |
| boolean retainAll(Collection c) | 지정된 Collection에 포함된 객체만 남기고 다른 객체들은 Collection에서 삭제한다. 이 작업으로 인해 Collection에 변화가 있으면 true, 그렇지 않으면 false를 반환한다. |
| int size() | Collection에 저장된 객체의 개수를 반환한다. |
| Object[] toArray() | Collection에 저장된 객체를 객체배열(Object[])로 반환한다. |
| Object[] toArray(Object[] a) | 지정된 배열에 Collection의 객체를 저장해서 반환한다. |

### List인터페이스
- 저장된 순서를 유지, 저장값 중복 허용
- List인터페이스의 메소드

| 메서드 | 설명 |
| --- | --- |
| void add(int index, Object element) boolean addAll(int index, Collection c) | 지정된 위치(index)에 객체 또는 컬렉션에 포함된 객체들을 추가 |
| Object get(int index) | 지정된 위치(index)에 있는 객체를 반환한다. |
| int indexOf(Object o) | 지정된 객체의 위치를 반환한다. |
| int lastIndexOf(Object o) | 지정된 객체의 위치를 역방향으로 반환한다. |
| ListIterator Iistlterator() listIterator listIterator(int index) | List의 객체에 접근할 수 있는 ListIterator를 반환한다. |
| Object remove(int index) | 지정된 위치에 있는 객체를 삭제하고 삭제된 객체를 반환한다. |
| Object set(int index, Object element) | 지정된 위치에 객체를 저장한다. |
| void sort(Comparator c) | 지정된 비교자로 List를 정렬한다. |
| List subList(int fromIndex, int toIndex) | 지정된 범위에 있는 객체를 반환한다. |

- `List`는 `Collection`의 메서드를 가지고 있으면서 추가적인 메서드를 또 가지고 있다.
  - 삭제(remove), 검색(indexOf), 정령(Sort) 등의 메소드

### Set인터페이스
- 저장된 순서를 유지하지 않고, 중복을 허용하지 않는다.
- Set인터페이스의 메서드는 Collection의 인터페이스와 동일.

### Map인터페이스
- 저장된 순서를 유지하지 않고, 중복은 값(vlaue)만 허용
- 단, `LinkeddHashMap`은 순서를 유지
- key, value의 형태
- Map 인터페이스의 메소드

| 메소드 | 설명 |
| --- | --- |
| void clear() | Map의 모든 객체를 삭제한다. |
| boolean containsKey(Object Key) | 지정된 key객체와 일치하는 Map의 Key객체가 있는지 확인한다. |
| boolean containsValue(Object value) | 지정된 value객체와 일치하는 Map의 value객체가 있는지 확인한다. |
| Set entrySet() | Map에 저장되어 있는 key-value쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환한다. |
| boolean equals(Object o) | 동일한 Map인지 비교한다. |
| int hashCode() | 해시코드를 반환한다. |
| boolean isEmpty() | Map이 비어있는지 확인한다. |
| Set KeySet() | Map에 저장된 모든 Key객체를 반환한다. |
| Object put(Object key, Object value) | Map에 value객체를 key객체에 연결하여 저장한다. |
| void putAll(Map t) | 지정된 Map의 모든 key-value쌍을 추가한다. |
| Object remove(Object key) | 지정된 key객체와 일치하는 key-vlaue객체를 삭제한다. |
| int size() | Map에 저장된 key-value쌍의 개수를 반환한다. |
| Collection values() | Map에 저장된 모든 value객체를 반환한다. |

## ArrayList
- `ArrayList`는 기존의 `Vector`를 개선한 것으로 구현원리와 기능적으로 동일
  - 단, `ArrayList`와 달리 `Vector`는 자체적으로 동기화처리가 되어있다.
- `List`인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- 데이터의 저장공간으로 배열을 사용한다.(배열 기반)
- `ArrayList`에는 기본형을 저장할 수 없지만, 컴파일러가 `autoboxing`으로 기본형을 참조형으로 자동 변환시켜 사용이 가능하다.

### ArrayList에 저장된 객체의 삭제과정
```java
System.arraycopy(data, 3, data, 2, 2);
```
- 삭제할 데이터 아래의 데이터를 한 칸씩 위로 복사해서 삭제할 데이터를 덮어쓴다.
```java
data[size-1] = null;
```
- 데이터가 모두 한 칸씩 이동했으므로, 마지막 데이터는 `null`로 변경한다.
```java
size--;
```
- 데이터가 삭제되어 데이터의 개수가 줄었으므로 `size`의 값 감소
> 마지막 데이터를 삭제하는 경우 1의 과정은 필요없다.
- 되도록 중간에 삽입, 삭제 과정을 최소화하는 것이 좋다.
```java
for (int i = 0; i < list1.size(); i++) {
    list1.remove(i);
}
for (int i = list2.size() - 1; i >= 0; i--) {
    list2.remove(i);
}
```
- 둘의 차이점이 무엇일까?
```java
// remove 진행 전
list1 = [0, 1, 2, 3, 4]
list2 = [0, 1, 2, 3, 4]
// remove 진행 후
list1 = [1, 3]
list2 = []
```
- 둘 다 `List`에 저장되어 있는 값을 전부 삭제하는것 같아 보이지만 그게 아니였다.
- 위에 코드는 앞쪽부터(`index`가 작은쪽부터) `remove`가 진행 -> 배열 복사가 발생(다 지워지지 않을뿐 아니라 느리다.)
- 아래 코드는 아래쪽부터 `remove`가 진행 -> 배열 복사가 발생안한다(빠르다)

### 배열의 장단점
- 장점
  - 배열은 구조가 간단하고 데이터를 읽는 데 걸리는(접근시간, access time) 시간이 짧다.
- 단점
  - 크기를 변경할 수 없다.
    - 크기를 변경해야 하는 경우 새로운 배열을 생성 후 데이터를 복사해야한다.(더 큰배열 생성 -> 복사 -> 참조 변경)
    - 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리 낭비가 심하다.
  - 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
    - 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옯겨야 한다.
    - 단, 데이터의 끝에 추가 또는 삭제하는 것은 빠르다.

## LinkedList(배열의 단점을 보완)
- 벼열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결
- 데이터의 삭제: 단 한 번의 참조변경만으로 가능
- 데이터의 추가: 한번의 `Node`객체생성과 두 번의 참조변경만으로 가능
  - Node: `LinkedList`안에 있는 요소
- 단점: 데이터의 접근성이 나쁘다.

### ArrayList(배열기반) vs LinkedList(연결기반)
- 순차적으로 데이터를 추가/삭제: `ArrayList`가 빠르다.
- 비순차적으로 데이터를 추가/삭제: `LinkedList`가 빠르다.
- 접근시간(access time): `ArrayList`가 빠르다.
  - `index`가 `n`인 데이터의 주소 = 배열의 주소 + `n` * 데이터 타입의 크기

## Stakc과 Queue
- 스택(Stack): LIFO(Last In First Out)구조, 마지막에 저장된 것을 제일 먼저 꺼내게 된다.
  - 저장(push)과 추출(pop)의 순서가 반대
- 큐(Queue): FIFO(First In First Out)구조, 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다.
  - 저장(offer)과 추출(poll)의 순서가 일치

### Stack의 메서드
| 메서드 | 설명 |
| --- | --- |
| boolean empty() | Stack이 비어있는지 알려준다. |
| Object peek() | Stack의 맨 위에 저장된 객체를 반환, pop()과 달리 Stack에서 객체를 꺼내지는 않는다. (Stakc이 비어있으면 EmptyStackException발생) |
| Object pop() | Stack의 맨 위에 저장된 객체를 꺼낸다(Stakc이 비어있으면 EmptyStackException발생) |
| Object push(Object item) | Stack에 객체를 저장한다. |
| int search(Object o) | Stack에서 주어진 객체를 찾아서 위치를 반환, 객체를 못찾으면 -1을 반환(배열과 달리 위치는 0이 아닌 1부터 시작) |

### Queue의 메서드
| 메서드 | 설명 |
| --- | --- |
| boolean add(Object o) | 지정된 객체를 Queue에 추가한다. 성공하면 true를 반환, 저장공간이 부족하면 IllegalStateException발생 |
| Object remove() | Queue에서 객체를 꺼내 반환 비어있으면 NoSuchElementException발생 |
| Object element() | 삭제없이 요소를 읽어온다. peek와 달리 Queue가 비었을 때 NoSuchElementExeption발생 |
| boolean offer(Object o) | Queue에 객체를 저장, 성공하면 true 실패하면 false를 반환 |
| Object poll() | Queue에서 객체를 꺼내서 반환, 비어있으면 null을 반환 |
| Object peek() | 삭제없이 요소를 읽어 온다. Queue가 비어있으면 null을 반환 |