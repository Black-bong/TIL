# 스프링 핵심원리

---

> 인프런에서 김영한님의 스프링 핵심원리 강의를 보고 요약, 정리한 글입니다.
>
>
> `강의 내용외에 직접 검색하고, 찾아본 내용도 함께 작성될 수 있습니다.`
>
> > 출처: <a href = https://www.inflearn.com/course/스프링-핵심-원리-기본편/dashboard>스프링 핵심원리 강의</a>
> >

---

## 1. 객체 지향 설계와 스프링

### 역할과 구현을 분리

- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다. → 유연하고 변경에 유리
- 클라이언트는 대생의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

### 자바 언어의 다형성을 활용

- 역할 = 인터페이스
- 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행할 객체 만들기

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 할 수 있다.

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- SRP: 단일 책임 원칙(single resoinsibility principle)
- OCP: 개방-폐쇠 원칙(Open/Closed principle)
- LSP: 리스코프 치환 원칙(Liskov substitution principle)
- ISP: 인터페이스 분리 원칙(Interface segregation principle)
- DIP: 의존관계 역전 원칙(Dependency inversion principle)

### SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다.
    - 이게 참 모호하다..
    - 클 수도 있고, 작을 수도 있다.
    - 문맥과 상황에 따라 다르다.
- 변경을 기준으로 변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것이다.

### OCP 개방-폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
- 다형성을 활용해보자.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 구현과 역할을 분리

### LSP 리스코프 치환 원칙

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서, 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.

### ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.
- 자동차 인터페이스 → 운전, 정비 인터페이스로 분리
- 사용자 클라이언트 → 운전자, 정비사 클라이언트로 분리
- 정비 인터페이스가 변해도 운전자 클라이언트에 영향을 주지 않는다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP 의존관계 역전 원칙

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
- 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

## 2. 스프링 핵심 원리 이해(예제 만들기)

### 비즈니스 요구사항 - 회원

- 회원을 가입하고 조회할 수 있다.
- 회원은 일반과 VIP 두 가지 등급이 있다.
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동 할 수 있다.

### 비즈니스 요구사항 - 주문과 할인 정책

- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다.
- 할인 정책은 모든 VIP는 1000원을 하인해주는 고정 금액 할인을 적용
- 할인 정책은 변경 가능성이 높다.

### 회원 도메인 협력 관계

<img src="https://user-images.githubusercontent.com/78953393/147388122-d01f35f8-c368-4500-95d3-c9bf240223e9.png" height="60%" width="40%">

### 회원 클래스 다이어그램

<img src="https://user-images.githubusercontent.com/78953393/147388124-c115190b-781a-4dd7-b81d-24b73f5bbacb.png" height="60%" width="40%">

### 회원 객체 다이어그램

<img src="https://user-images.githubusercontent.com/78953393/147388125-67fa3eaa-1f5d-4b11-af42-62afd171af39.png" height="60%" width="40%">

### 회원 도메인 개발

- 스프링 없이 순수 자바로만 개발

```java
public class Member {
    private Long id;
    private String name;
    private Grade grade;
...
}
```

- Member 클래스

```java
public interface MemberRepository {
    void save(Member member);
    Member findById(Long memberId);
}
```

- 멤버 저장소를 인터페이스로 선언

```java
public class MemoryMemberRepository implements MemberRepository {
    private static Map<Long, Member> store = new HashMap<>();
    
    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }
    
    @Override
    public Member findById(Long memberId) {
        return store.get(memberId);
    }
}
```

- 앞으로 사용될 DB가 정해지지 않았기 때문에 우선 개발을 위해 메모리 저장으로 만들고 추후 DB가 정해지면, 구현체를 변경하여 사용
- 메모리에 저장되는 저장소 생성
- 저장과 조회 기능

```java
public interface MemberService {
    void join(Member member);
    Member findMember(Long memberId);
}
```

- 멤버 서비스 인터페이스로 선언

```java
public class MemberServiceImpl implements MemberService {
    private final MemberRepository memberRepository = new MemoryMemberRepository();
    
    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```

- 멤버 서비스 구현체
- 구현체가 하나면 인터페스명 뒤에 Impl의 붙이는것이 관례이다.
- 다형성을 잘 활용하였지만, 이게 과연 좋은 객체지향 설계에 부합할까?

### 회원 도메인 실행과 테스트

```java
public class MemberApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        Member member = new Member(1L, "memberA", Grade.VIP);
        memberService.join(member);
        
        Member findMember = memberService.findMember(1L);
    
        System.out.println("new member = " + member.getName());
        System.out.println("findMember = " + findMember.getName());
    }
}
```

- 순수한 자바로만 이루어져 있다.
- 메인 클래스를 만들어서 테스트하는것은 한계가 뚜렷하다, 테스트 코드 작성해서 테스트

```java
import org.junit.jupiter.api.Test;

public class MemberServiceTest {
	
    MemberService memberService = new MemberServiceImpl();
    
    @Test
    void join() {
        // given
        Member member = new Member(1L, "memberA", Grade.VIP);

        // when
        memberService.join(member);
        Member findMember = memberService.findMember(1L);
        
        // then
        Assertions.assertThat(member).isEqualTo(findMember);
    }
}
```

- `Assertions`를 사용(단, `org.assertj.core.api`에 있는 Assertions를 사용)
- 테스트코드는 선택이 아닌 필수!

### 주문 도메인 역할

<img src="https://user-images.githubusercontent.com/78953393/147388127-2fa4d748-4dbf-410f-96d4-7713c851781a.png" height="60%" width="40%">

- 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
- 회원 조회: 할인을 위해서 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회
- 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임
- 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.
    - 실제로는 주문 데이터를 DB에 저장하지만, 지금은 단순하게 주문 결과를 반환

### 주문 도메인 전체

<img src="https://user-images.githubusercontent.com/78953393/147388128-3cafc743-fb64-4557-b0b2-eefe31a8bf60.png" height="60%" width="40%">

### 주문과 할인 도메인 개발

```java
public interface DiscountPolicy {
    int discount(Member member, int price);
}
```

- 할인 인터페이스

```java
public class FixDiscountPolicy implements DiscountPolicy {
	
    private int discountFixAmount = 1000;
    
    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return discountFixAmount;
        }
        return 0;
    }
}
```

- 고정 할인 구현
- 고객 등급이 VIP이면, 고정 금액을 반환해준다.

```java
public class Order {
    private Long memberId;
    private String itemName;
    private int itemPrice;
    private int discountPrice;

    public int calculatePrice() {
        return itemPrice - discountPrice;
    }
}
```

- 주문 객체
- `calculatePrice()`아이템 가격에서 할인 금액을 뺀 최종 금액을 계산하여, 반환해준다.

```java
public interface OrderService {
    Order createOrder(Long memberId, String itemName, int itemPrice);
}
```

- 오더 서비스 인터페이스
- 클라이언트에서 요청하여 생성된 주문 내역을 반환해주는 역할

```java
public class OrderServiceImpl implements OrderServie {

    private final MemberRepository = new MemoryMemberRepository();
    private final DiscountPolicy = new FixDiscountPolicy();	

    @Override
    Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = MemberRepository.findById(memberId);
        int discountPrice = DiscountPolicy.discount(member, itemPrice);
        
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

- 주문 생성 요청 시 회원 정보 조회 후 등급에 맞는 할인 정책에 멤버와 아이템 가격을 넘겨, 할인 후의 금액을 반환받고
- 주문내역을 완성하여 반환한다.

### 주문과 할인 도메인 테스트

```java
public OrderApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        OrderService orderService = new OrderServcieImpl();
        
        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);		
        memberService.join(member);

        Order order = orderService.createOrder(memberId, "itemA", 10000);
        System.out.println("order=" + order);
        System.out.println("order.calculatePrice=" + order.calculatePrice());
    }
}
```

- 메인 메서드를 이용한 테스트, 물론 좋지 않은 방법

```java
public class OrderServiceTest {
    MemberService memberService = new MemberServiceImpl();
    OrderService orderService = new OrderServiceImpl();
    
    @Test
    void createOrder() {
        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);
        memberService.join(member);
        
        Order order = new Order(member, "itemA", 10000);
        Assertions.assertThat(order.getDiscountPrice()).isEquelTo(1000);
    }
}
```

- 테스트 코드 작성을 꾸준하게 연습해보자.
- 단위 테스트가 정말 중요하다.
- 여기서 단위 테스트란, 스프링이나 컨테이너의 도움없이 순수한 자바 코드하는 테스트

### 설계의 문제점

- 지금까지 작성한 순수 자바코드로 이루어진 도메인 설계는 SOLID의 원칙중 OCP와 DIP를 위반하고 있다.
- 새로운 할인 정책이 주어졌을때, 코드를 변경해보면서 DIP나 OCP가 잘 지켜졌는지 확인해보자

## 3. 스프링 핵심 원리 이해2(객체 지향 원리 적용)

### 새로운 할인 정책 개발

- VIP등급 무조건 1000원 할인에서 주문금액별 %할인으로 변경

```java
public class RateDiscountPolicy implements DiscountPolicy {

    private int discountPersent = 10;	

    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return price * discountPersent / 100;
        }
        return 0;
    }
}
```

- RateDiscountPolicy 추가

```java
class RateDiscountPolicyTest {
	
    DiscountPolicy discountPolicy = new RateDiscountPolicy();

    @Test
    @DisplayName("VIP는 10% 할인이 적용되어야 한다.")
    void 변동_할인_적용_테스트() {
        // given
        Member member = new Member(1L, "memberA", Grade.VIP);
        // when
        int discount = discountPolicy.discount(member, 10000);
        // then
        Assertions.assertThat(discount).isEqualTo(1000);
    }

    @Test
    @DisplayName("VIP가 아니면 할인 적용이 안되야한다..")
    void 변동_할인_적용_테스트() {
        // given
        Member member = new Member(2L, "memberBASIC", Grade.BASIC);
        // when
        int discount = discountPolicy.discount(member, 10000);
        // then
        Assertions.assertThat(discount).isEqualTo(0);
    }
}
```

- RateDiscountPolicy 테스트
- 맥 기준 `command + shift + T`단축키를 사용해서 테스트 클래스 생성
- `@DisplayName`테스트 결과창에 출력되는 메소드 명을 바꿔준다.
- 성공 테스트도 중요하지만, 실패 테스트도 꼭 만들어 봐야한다.

### 새로운 할인 정책 적용

- 새로운 할인 정책 시 발생되는 문제점

```java
public class OrderServiceImpl implements OrderServie {

    private final MemberRepository = new MemoryMemberRepository();
    // private final DiscountPolicy = new FixDiscountPolicy();
    private final DiscountPolicy = new RateDiscountPolicy();
    

    @Override
    Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = MemberRepository.findById(memberId);
        int discountPrice = DiscountPolicy.discount(member, itemPrice);
        
        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

- 역활과 구현을 분리: OK
- 다형성을 활용하고, 인터페이스와 구현체를 분리: OK
- OCP, DIP 같은 객체지향 설계 원칙 준수: 그렇게 보이지만 실상은 X
- DIP: 주문서비스 클라이언트(`OrderServiceImpl`)은 `DiscountPolicy` 인터페이스에 의존하면서 DIP를 지킨것 같지만,
    - 추상클래스 뿐만 아니라 구현클래스에도 의존하고 있다.
    - 추상(인터페이스)클래스 의존: `DiscountPolicy`
    - 구체(구현)클래스 의존: `RateDiscountPolicy`, `FixDiscountPolicy`
- OCP: `FixDiscountPolicy`에서 `RateDiscountPolicy`로 변경을 하는 순간, 아주 작은 부분이지만 `OrderServiceImple`의 코드가 변경되므로, OCP위반

### 문제 해결

- DIP 위반의 문제를 해결하기 위해 구체클래스가 아닌 추상클래스만 의존하도록 변경

```java
public class OrderServiceImpl implements OrderServie {

    // private final DiscountPolicy = new RateDiscountPolicy();
    private final DiscountPolicy;
...
}
```

- 구체 클래스에 의존하던 것을 없애고, 추상클래스에만 의존하도록 코드 변경
    - `private final DiscountPolicy = new RateDiscountPolicy();` → `private final DiscountPolicy;`
    - 하지만 구현클래스 없이 프로그램을 실행하면, 당연하게도 `NullPointerException`예외가 발생하고 만다.
- 그럼 어떻게 문제를 해결해야 할까?
    - 누군가 대신 구현체를 생성해서 `OrderServiceImpl`에 의존성을 주입해줘야한다.

### 관심사의 분리

```java
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy())
    }
    public MemberRepository memberRepository() {
        return new MemoryMemberRespository();
    }
    public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }   
}
```

- `AppConfig`클래스 생성
- `AppConfig`클래스는 앱의 전반적인 설정을하고 구성하는 역할
- `AppConfig`에서 애플리케이션의 실제 동작에 필요한 구현 객체를 생성

```java
public class MemberServiceImpl implements MemberService {

    private final MemberRepository memberRepository;
    
    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
    ...
}
```

- 생성자를 통해서 구현체가 어떤것이 쓰일것인지 확인 → 생성자 주입
- 설계 변경으로 `MemberServiceImpl`은 `MemoryMemberRepository` 를 의존하지 않는다.
- `MemberServiceImpl`입장에서는 어떤 구현 객체가 주입될지 알 수 없으며, 오직 외부(`AppConfig`)에서 결정된다.
- `MemberServiceImpl`은 의존관계에 대한 것은 외부에 맡기고 오직 로직을 실행하는 것만 신경쓰면 된다.
- 객체의 생성하고 연결하는 역할과, 실행하는 역할이 명확하게 분리되었다.

```java
public class MemberApp {
    public static void main(String[] args) {
        AppConfig appConfig = new AppConfig;
        MemberService memberService = appConfig.memberService();
        Member member = new Member(1L, "memberA", Grade.VIP);
        memberService.join(member);
        
        Member findMember = memberService.findMember(1L);
    
        System.out.println("new member = " + member.getName());
        System.out.println("findMember = " + findMember.getName());
    }
}
```

- `AppConfig`를 통해서, 의존관계를 주입받는다.

### 새로운 구조와 할인 정책 적용

- 정액할인 정책에서 정률할인 정책으로 변경해보자!

```java
public class AppConfig {
    ...
    public DiscountPolicy discountPolicy() {
        // return new FixDiscountPolicy();
        return new RateDiscountPolicy();
    }
}
```

- 새로운 할인 정책을 적용할때 사용영역의 코드는 건들필요없이 구성영역에 있는 코드만 변경해주면된다.
- `FixDiscountPolicy()` → `RateDiscountPolicy()`로 변경
- `OrderServiceImpl`안에 있는 코드는 변경할 필요 없이, `AppConfig`안에 코드만 변경해주면 끝!
- 클라이언트 코드 변경없이 앱의 기능을 확장할 수 있다. → OCP 만족!!

### 전체 흐름 정리

- 새로운 할인 정책 개발 → 다형성을 활용하여 잘 개발하였으나, 적용과정에서 OCP와 DIP를 위반
- 관심사의 분리 → 클라이언트가 두가지의 역할을 가지고 있던것을 분리
- AppConfig 리펙터링 → 구성 정보에서 역할과 구현을 명확하게 분리, 중복제거
- 새로운 구조와 할인 정책 적용 → `AppConfig`의 등장으로 애플리케이션이 크게 **사용영역**과 객체를 **구성(Configuration)하는 영역으로 분리**
- 할인 정책을 변경해도 `AppConfig`가 있는 구성 영역만 변경하면됨, 사용 영역은 변경할 필요가 없다.

### 좋은 객체 지향 설계의 5가지 원칙 적용

- SRP 단일 책임 원칙
    - 단일 책임 원칙을 따르면서 관심사를 분리
    - 구현 객체를 생성하고 연결하는 책임은 `AppConfig`가 담당
    - 클라이언트 객체는 실행하는 책임만 담당
- DIP 의존관계 역전 원칙
    - 구현 클래스와 추상 클래스에 둘 다 의존하면서 DIP원칙 위반
    - 클라이언트가 추상 클래스만 의존하도록 코드변경
    - 클라이언트 코드는 인터페이스만으로는 실행이 불가
    - `AppConfig`가 객체를 대신 생성하고 의존관계를 주입해 주면서, DIP원칙을 따르도록 문제 해결
- OCP 개방-폐쇄 원칙
    - 애플리케이션을 사용 영역과 구성 영역으로 나눔
    - 정액할인에서 정률할인으로 할인 정책을 변경했음에도 클라이언트 코드는 변경되지 않음

### IoC(Inversion of Control) 제어의 역전

- 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름이다.
- 프로그램에 대한 제어 흐름에 대한 권한은 모두 `AppConfig`가 가지고 있다. 구현 객체는 묵묵히 자신의 로직을 실행할 뿐이다.
- 심지어 구현객체의 생성 또한 `AppConfig`가 생성한다.
- 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)라고 한다.

### 프레임워크 vs 라이브러리

- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다.(ex JUnit)
- 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다.

### DI(Dependency Injection) 의존관계 주입

- 인터페이스만 의존, 실제 어떤 구현 객체가 사용될지는 모른다.
- 의존관계는 `정적인 클래스 의존관계` 와 실핼 시점에 결정되는 `동적인 객체(인스턴스) 의존관계` 둘을 분리해서 생각해야 한다.
    - `정적인 클래스 의존관계`: 클래스가 사용하는 import 코드만 보고 의존관계를 파악 할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석 가능하다.
    - `동적인 객체(인스턴스) 의존관계`: 애플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경할 필요없이, 동적인 객체 인스턴스 의존관계를 변경 할 수 있다.

### IoC컨테이너, DI컨테이너

- `AppConfig`처럼 객체를 생성하고, 관리하면서 의존관계를 연결해 주는것
- 주로 DI컨테이너라 하며 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

### 스프링으로 전환하기

- 지금까지 순수한 자바 코드만으로 DI를 적용.
- 이제는 스프링을 사용해보자!

```java
@Configuration
public class AppConfig {

    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }
    @Bean
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy())
    }
    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRespository();
    }
    @Bean
    public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }
}
```

- `AppConfig`에서 `@Configuration`과 `@Bean`어노테이션 사용
- `import org.springframework.context.annotation.Configuration;` 이걸 사용해야한다. `import`할때는 항상 주의
- `@Configuration`: 애플리케이션을 설정하는 설정 정보에 명시해줘야한다.
- `@Bean`: key는 메서드 이름 value는 객체 인스턴스로 스프링 컨테이너에 등록(싱글톤)

```java
public class MemberApp {
    public static void main(String[] args) {
        // AppConfig appConfig = new AppConfig;
        // MemberService memberService = appConfig.memberService();
        
        ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
        ac.getBean("memberService", MemberService.class);
    
        Member member = new Member(1L, "memberA", Grade.VIP);
        memberService.join(member);
        
      Member findMember = memberService.findMember(1L);
    
        System.out.println("new member = " + member.getName());
        System.out.println("findMember = " + findMember.getName());
    }
}
```

- `MemberApp`을 스프링을 사용하는 버전으로 변경
- `ApplicationContext`: 스프링의 모든것이 시작되는 시작점, 스프링 컨테이너라 보면 된다(모든 객체를 관리해준다)
- `AnnotationConfigApplicationContext(AppConfig.class)`: `AppConfig`에 있는 환경설정을 가지고 스프링이 `@Bean`이 붙은 객체를 스프링 컨테이너에 집어넣고 관리해준다.
- `ac.getBean("name", 타입)`: `AppConfig`에 있는 객체를 꺼내오는 역할을하며 `name`은 기본적으로 메서드 이름으로 자동 설정된다.

### 스프링 컨테이너

- `ApplicationContext`를 스프링 컨테이너라 한다.
- 기존에는 `AppConfig`를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제부턴 스프링 컨테이너를 통해서 사용한다.

```java
@Configuration
public class AppConfig {

    @Bean
    public MemberService memberService() {
        System.out.println("call AppConfig.memberService");
        return new MemberServiceImpl(memberRepository());
    }
        
    @Bean(name = MemoryMemberRepository)
    public MemoryMemberRepository memberRepository() {
        System.out.println("call AppConfig.memberRepository");
        return new MemoryMemberRepository();
    }
    ...
}
```

- 스프링 컨테이너는 `@Configuration`이 붙은 `AppConfig`를 설정(구성) 정보로 사용한다. 여기서 `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록하며, 이렇게 등록된 객체를 스프링 빈이라고 한다.
- `@Bean(name = "name")`형식을 사용해 스프링 빈의 이름을 변경 할 수도 있다.(특별한 경우가 아닌 이상 기본 설정이 제일 좋다)

```java
public static void main(String[] args) {

    ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
    MemberService memberService = ac.getBean("memberService", MemberService.class);
    ...
}
```

- 스프링 빈은 메서드의 명을 스프링 빈의 이름으로 사용한다.
- `.getBean()`메서드를 사용해서 스프링 컨테이너에 있는 스프링 빈을 찾아서 사용해야한다.

## 4. 스프링 컨테이너와 스프링 빈

### 스프링 컨테이너 생성

```java
public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,
    MessageSource, ApplicationEventPublisher, ResourcePatternResolver {
    ...
}
```

- `ApplicationContext`는 인터페이스이다.
- `AppConfig`를 사용했던 방식이 어노테이션 기반의 자바 설정 클래스로 스프링 컨테이너를 만든것.
- `AnnotationConfigApplicationContext`는 `ApplicationContext`의 구현체이다.

### 스프링 컨테이너 생성 과정

1. 스프링 컨테이너 생성
    1. 스프링 컨테이너를 생성할 때는 구성 정보(`AppConfig`)를 지정해주어야한다.
    2. `new AnnotationConfigApplicationContext(AppConfig.class)`으로 정보 전달
    3. 스프링 컨테이너 속 스프링 빈 저장소 생성
2. 스프링 빈 등록
    1. 넘긴 설정정보를 사용해서 `@Bean`어노테이션을 찾고, 어노테이션이 붙어있는 메서드의 이름(빈 이름)과 반환 객체(빈 객체)를 스프링 컨테이너 속 스프링 빈 저장소에 저장한다.
    2. 이렇게 저장된 것이 스프링 빈이다.
    3. 스프링 빈 이름은 항상 다른 이름을 부여해야한다.
    4. 스프링 빈 저장소

    ```java
    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(memberServiceRepository());
    }
    
    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
    ```

   | 빈 이름 | 빈 객체 |
   | --- | --- |
   | memberService | MemberServiceImpl@x01 |
   | memberRepository | MemoryMemberRepository@x02 |
   
    - 빈 이름은 메서드 이름을 사용한다.
3. 스프링 빈 의존관계 설정 - 준비
4. 스프링 빈 의존관계 설정 - 완료
    1. 설정 정보를 참고해서 스프링 컨테이너가 의존관계를 주입(DI) 해준다.
    2. 단순히 자바 코드를 호출하는 것 같지만, 큰 차이가 있다.(싱글톤)

### 컨테이너에 등록된 모든 빈 조회

- 스프링 컨테이너에 등록되어 있는 모든 빈에 대한 정보 출력

```java
class ApplicationContextInfoTest() {
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppCofig.class);

    @Test
    @DisplayName("모든 빈 출력하기")
    void findAll() {
        String[] beanDefinitionNames = ac.getBeanDifinitionNames();
        
        for (String beanDefinitionName : beanDefinitionNames) {
            Object bean = ac.getBean(beanDefinitionName);
            System.out.println("name = " + beanDefinitionName + " object = " + bean);
        }
    }
}
```

- `.getBeanDefinitionNames()`: 스프링 컨테이너에 있는 빈 이름을 출력해주는 메소드(key)
- `.getBean`: 스프링 컨테이너에 등록되어 있는 빈 객체를 출력(value)

```java
class ApplicationContextInfoTest() {
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppCofig.class);

    @Test
    @DisplayName("애플리케이션 빈 출력하기")
    void findApplicationBean() {
        String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        
        for (String beanDefinitionName : beanDefinitionNames) {
            BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefiniionName);
            
            if (beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION) {
                Object bean = ac.getBean(beanDefinitionName);
                System.out.println("name = " + beanDefinitionName + " object = " + bean);
            }
        }	
    }
}
```

- 스프링 컨테이너에 기본적으로 등록되어 있는것 외에 애플리케이션 개발을 위해 등록한 스프링 빈만 출력
- `.getBeanDefinition`: 빈 하나하나의 메타데이터 정보를 가져오는 메서드
- `beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION`: 스프링 내부에서 등록한 빈이 아닌 내가 애플리케이션을 개발하기 위해 등록한 빈 조회
- `beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION`: 스프링이 내부에서 사용하는 빈 조회

### 스프링 빈 조회 - 기본

- `ac.getBean(빈 이름, 타입)`또는 `ac.getBean(타입)`를 사용
- 조회 대상 스프링 빈이 없으면 예외 발생
    - `NoSuchBeanDefinitionException: No bean named 'xxxx' available`

```java
import static org.assertj.core.api.AssertionsForClassTypes.assertThat;

class ApplicationContextBasicFindTest {

    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class);
    
    @Test
    @DisplayName("빈 이름으로 조회")
    void findByBeanName() {
        MemberService memberService = ac.getBean("memberService", MemberService.class);
        assertThat(memberService).isTnstanceOf(MemerServiceImpl.class);
    }
}
```

- 빈 이름으로 조회

```java
import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
...
class ApplicationContextBasicFindTest {
    @Test
    @DisplayName("빈 타입으로만 조회")
    void findByBeanName() {
        MemberService memberService = ac.getBean(MemberService.class);
        assertThat(memberService).isTnstanceOf(MemerServiceImpl.class);
    }
}
```

- 빈 타입으로만 조회

```java
import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
...
class ApplicationContextBasicFindTest {
    @Test
    @DisplayName("구체 타입으로 조회")
    void findByBeanName() {
        MemberService memberService = ac.getBean("memberService", MemberServiceImpl.class);
        assertThat(memberService).isTnstanceOf(MemerServiceImpl.class);
    }
}
```

- 구체 타입으로 조회
    - 구현에만 의존해야하는데 구현체에 의존하기 때문에 좋지 않은 방법

```java
import static org.junit.jupiter.api.Assertions.assertThrows;
...
class ApplicationContextBasicFindTest {
    @Test
    @DisplayName("없는 빈 조회 시 예외 발생")
    void noSuchBean() {
        assertThrows(NoSuchBeanDefinitionException.class,
            () -> ac.getBean("xxxx", MemberService.class));
    }
}
```

- 해당 빈이 없을때 예외발생
    - `Assertions.assertThrows()`를 사용
    - `org.junit.jupiter.api.Assertions`를 `inport`해야 `assertThrows()`사용가능

### 스프링 빈 조회 - 중복

```java
@Configuration
static class SameBeanConfig {
    @Bean
    public MemberRepository memberRepository1() {
        return new MemoryMemberRepository();
    }
    @Bean
    public MemberRepository memberRepository2() {
        return new MemoryMemberRepository();
    }
}
```

- 테스트를 위한 임의의 `Config`생성
- 파라미터의 값에 따른 변경점이 있을 수도 있어 충분히 실무에서도 나올수 있는 코드.

```java
import static org.junit.jupiter.api.Assertions.assertThrows;

class ApplicationContextSameBeanFindTest {
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class);

  @Test
  @DisplayName("타입으로 조회시 같은 타입이 둘 이상이면 중복 오류가 발생한다.")
  void findBeanByTypeDuplicate() {
    assertThrows(NoUniqueBeanDefinitionException.class,
      () -> ac.getBean(MemberRepository.class));
  }
}
```

- `NoUniqueBeanDefinitionException`예외 발생

```java
import static org.junit.jupiter.api.Assertions.assertThrows;

class ApplicationContextSameBeanFindTest {
    @Test
    @DisplayName("타입으로 조회시 같은 타입이 둘 이상이면, 빈 이름으로 조회하면 된다.")
    void findBeanByName() {
    MemberRepository memberRepository1 = ac.getBean("memberRepository1", MemberRepository.class);
    assertThat(memberRepository1).isInstanceOf(MemberRepository.class);
    }
}
```

- 스프링 빈 조회 시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다. 이떄 빈 이름을 지정하면 해결할 수 있다.

```java
import static org.assertj.core.api.Assertions.assertThat;

class ApplicationContextSameBeanFindTest {
  @Test
  @DisplayName("특정 타입을 모두 조회하기")
  void findAllBeanType() {
      Map<String, MemberRepository> beansOfType = ac.getBeansOfType(MemberRepository.class);
      for (String key : beansOfType.keySet()) {
          System.out.println("key = " + key + " value = " + beansOfType.get(key));
      }
      System.out.println("beansOfType = " + beansOfType);
      assertThat(beansOfType.size()).isEqualTo(2);
  }
}
```

- `.getBeansOfType()`: 특정 타입의 스프링 빈 모두 조회

### 스프링 빈 조회 - 상속 관계

```java
@Configuration
static class TestConfig {
    @Bean
    public DiscountPolicy ratedDiscountPolicy() {
        return new RateDiscountPolicy();
    }

    @Bean
    public DiscountPolicy fixDiscountPolicy() {
        return new FixDiscountPolicy();
    }
}
```

- 테스트를 위한 임의의 `Config`생성

```java
@Test
@DisplayName("부모 타입으로 전부 조회")
void findAllBeanByParentsType() {
  Map<String, DiscountPolicy> beansOfType = ac.getBeansOfType(DiscountPolicy.class);
  for (String key : beansOfType.keySet()) {
    System.out.println("key  = " + key + " value = " + beansOfType.get(key));
  }
  assertThat(beansOfType.size()).isEqualTo(2);
}
```

- 부모 타입으로 조회 시 자식 타입도 전부 함께 조회된다.

```java
@Test
@DisplayName("부모 타입으로 전부 조회 - Object")
void findAllBeanByObjectType() {
  Map<String, Object> beansOfType = ac.getBeansOfType(Object.class);
  for (String key : beansOfType.keySet()) {
    System.out.println("key = " + key + " value = " + beansOfType.get(key));
  }
}
```

- `Object`타입으로 조회하면, 모든 스프링빈을 조회한다.

```java
@Test
@DisplayName("부모 타입으로 조회시, 자식이 둘 이상이면 중복 오류가 발생한다.")
void findBeanByParentsTypeDuplicate() {
  assertThrows(NoUniqueBeanDefinitionException.class, () -> ac.getBean(DiscountPolicy.class));
}
```

- 부모 타입으로 조회 시 자식이 둘 이상 있으면 중복오류가 발생한다.

```java
@Test
@DisplayName("부모 타입으로 조회시, 자식이 둘 이상 있으면, 빈 이름을 지정하면 된다.")
void findBeanByParentsTypeBeanName() {
  DiscountPolicy ratedDiscountPolicy = ac.getBean("ratedDiscountPolicy", DiscountPolicy.class);
  assertThat(ratedDiscountPolicy).isInstanceOf(RateDiscountPolicy.class);
}
```
- 부모 타입으로 조회시 자식이 둘 이상 있으면 빈이름을 지정하면 된다.
### BeanFactory란?

- 스프링 컨테이너의 최상위 인터페이스다.
- 스프링 빈을 조회하고 관리하는 역할을 한다.
- `getBean()`을 제공한다.

### ApplicationContext란?

- `BeanFactory`의 모든 기능을 상속받아 제공한다.
- `BeanFactory`와 `ApplicationContext`의 차이가 뭘까?
- `ApplicationContext`는 애플리케이션을 개발할때 필요한 부가 기능을 가지고 있다.

### ApplicationContext의 부가기능

- 메세지 소스를 활용한 국제화 기능: 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어권으로 출력
- 환경변수: 로컬, 개발, 운영등을 구분해서 처리
- 애플리케이션 이벤트: 이벤트를 발행하고 구독하는 모델을 편리하게 지원
- 편리한 리소스 조회: 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

### 어노테이션 기반 자바 코드 설정 사용

- 지금까지 했던 것
- 제일 많이 사용한다.

### XML 설정 사용

- 과거에 많이 사용
- 컴파일 없이 빈 설정 정보를 변경할 수 있는 장점도 있다.
- `GenericXmlApplicationContext`를 사용하면 `xml`설정 파일을 넘기면 된다.

```xml
<?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    
    
    <bean id="memberService" class="hello.core.service.MemberServiceImpl">
      <constructor-arg name="memberRepository" ref="memberRepository"/>
    </bean>
    
    <bean id="memberRepository" class="hello.core.repository.MemoryMemberRepository"/>
    
    <bean id="orderService" class="hello.core.service.OrderServiceImpl">
      <constructor-arg name="memberRepository" ref="memberRepository"/>
      <constructor-arg name="discountPolicy" ref="discountPolicy"/>
    </bean>
    
    <bean id="discountPolicy" class="hello.core.discount.RateDiscountPolicy"/>
</beans>
```

- 간단하게 실습해보고, 필요하면 공식 문서를 찾아보자.

### 스프링 빈 설정 메타 정보 - BeanDefinition

- `BeanDefinition`이라는 추상화가 있기 때문에 다양한 설정 형식을 사용할 수 있다.
- `BeanDefinition`을 빈 설정 메타 정보라 한다.
- 스프링 컨테이너는 이 메타 정보를 바탕으로 스프링 빈을 생성한다.
- `ApplicationConfigAppilcationContext`는 `AnnotationBeanDefinitionReader`를 사용해서 `AppConfig.class`를 읽고 `BeanDefinition`을 생성한다.

## 5. 싱글톤 컨테이너

### 웹 애플리케이션과 싱글톤

- 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.

```java
class SingletonTest {
    @Test
    @DisplayName("스프링 없는 순수한 DI 컨테이너")
    void pureContainer() {
        AppConfig appConfig = new AppConfig();
        MemberService memberService1 = appConfig.memberService();
        MemberService memberService2 = appConfig.memberService();
        
        assertThat(memberService1).isNotSameAs(memberService2);
    }
}
```

- `AppConfig`에서는 고객의 요청 시 마다 새로운 객체를 생성하게 되는데 여기서 문제점이 발생한다.
- 고객의 요청시 마다 새로운 객체를 생성하는지 테스트
- 메모리의 낭비가 심각하다.
- 해당 객체가 딱 1개만 생성되고 공유하도록 설계 → 싱글톤

### 싱글톤 패턴

```java
public class SingletonService {
    private static final SingletonService instance = new SingletonService();
    
    public static SingletonService getInstance() {
        return instance;
    }
    
    private SingletonService() { }
}
```

- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴
- 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야한다.
    - `private`생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막는다.
    - `same`: == (객체를 비교)
    - `equals`: 값 그 자체를 비교
- 생성자를 `private`으로 선언해서 외부에서 `new`키워드를 사용한 객체 생성을 못하게 막는다.

```java
@Test
@DisplayName("싱글톤 패턴을 적용한 객체 사용")
void singletonServiceTest() {
  SingletonService singletonService1 = SingletonService.getInstance();
  SingletonService singletonService2 = SingletonService.getInstance();

  System.out.println("singletonService1 = " + singletonService1);
  System.out.println("singletonService2 = " + singletonService2);

  assertThat(singletonService1).isSameAs(singletonService2);
}
```

- 여러번 객체를 호출했으나, 하나의 객체만 생성되고 공유해서 사용된다.
- 싱글톤 패턴을 구현하는 방법은 다양하다.

### 싱글톤 패턴의 문제점

- 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
- DIP를 위반한다.
    - 구현 클래스를 의존한다.
- 클라이언트가 구체 클래스를 의존하기 때문에 OCP를 위반할 가능성이 높다.
- 유연성이 떨어진다.
    - 내부 속성의 변경, 초기화가 어렵다.
    - 자식 클래스를 만들기 어렵다.
- 안티패턴으로 불리기도 한다.

### 싱글톤 컨테이너

```java
@Test
@DisplayName("스프링 컨테이너와 싱글톤")
void springContainer() {
    AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);

    MemberService memberService1 = ac.getBean("memberService", MemberService.class);
    MemberService memberService2 = ac.getBean("memberService", MemberService.class);

    System.out.println("memberService1 = " + memberService1);
    System.out.println("memberService2 = " + memberService2);

    assertThat(memberService1).isSameAs(memberService2);
}
```

- 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
- 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 한다.
- 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하고, 객체를 싱글톤으로 관리할 수 있다.
    - 싱글톤 패턴을 적용하기 위한 코드 작성이 필요없다.
    - `DIP`, `OCP`, `private생성자`, `test`로 부터 자유롭게 싱글톤을 사용할 수 있다.

### 싱글톤 방식의 주의점

```java
public class StatefulService {
    private int price;

    public void order(String name, int price) {
        System.out.println("name = " + name + " price = " + price);
        this.price = price;
    }

    public int getPrice() {
        return price;
    }
}
```

- 싱글톤 객체는 상태를 유지(stateful)하게 설계해서는 안된다.

```java
public class StatefulServiceTest {

    @Test
    void statefulServiceSingleton() {
        ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);
        StatefulService statefulService1 = ac.getBean(StatefulService.class);
        StatefulService statefulService2 = ac.getBean(StatefulService.class);
    
        // ThreadA: A사용자 10000원 주문
        statefulService1.order("UserA", 10000);
        // ThreadB: B사용자 20000원 주문
        statefulService2.order("UserB", 20000);
    
        int price = statefulService.getPrice();
        System.out.println("price = " + price);
    
        assertThat(statefulService1.getPrice()).isEqualTo(20000);
    }
    
    static class TestConfig {
        @Bean
        public StatefulService statefulService() {
            return new StatefulService();
        }
    }
}
```

- 사용자 A가 주문 금액을 조회했는데 2만원이 찍히는 문제가 발생한다.
- 스프링 빈 필드에 공유 값을 설정하면 큰일난다!

```java
public class StatefulService {
    // private int price;

    public void order(String name, int price) {
        System.out.println("name = " + name + " price = " + price);
        // this.price = price;
        return price;
    }
}
```

- 무상태(stateless)로 설계해야 한다.
    - 특정 클라이언트에 의존적이면 안된다.
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
    - 가급적 읽기만 가능해야한다.
    - 지역변수, 파라미터, ThreadLocal 등을 사용해야한다.

```java
public class StatefulServiceTest {

    @Test
    void statefulServiceSingleton() {
    ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class);
    StatefulService statefulService1 = ac.getBean(StatefulService.class);
    StatefulService statefulService2 = ac.getBean(StatefulService.class);

    // ThreadA: A사용자 10000원 주문
    int priceUserA = statefulService1.order("UserA", 10000);
    // ThreadB: B사용자 20000원 주문
    int priceUserB = tatefulService2.order("UserB", 20000);

    System.out.println("priceUserA = " + priceUserA);
    System.out.println("priceUserB = " + priceUserB);

    assertThat(priceA).isEqualTo(10000);
    }
    
    static class TestConfig {
        @Bean
        public StatefulService statefulService() {
            return new StatefulService();
        }
    }
}
```

### @Configuration과 싱글톤

- `AppConfig`에서 싱글톤이 깨질까?
- 테스트 결과 깨지지 않는다.. 이유는 다음 챕터에서 알아보자

### @Configuration과 바이트코드 조작

- 스프링이 `CGLIB`라는 바이트코드 조작 라이브러리를 사용해서 `AppConfig`클래스를 상속받는 임의의 다른 클래스를 만들고 그 클래스를 스프링 빈으로 등록
- 이 임의의 클래스가 싱글톤을 보장되도록 해준다.
- `@Configuration`의 사용없이 `@Bean`만 사용하게 되면 어떻게 될까?
    - `CGLIB`라이브러리를 사용할 수 없기 때문에 싱글톤이 깨지게 된다.
    - `@Bean`사용해도 스프링 빈으로 등록이 되나 싱글톤을 보장하진 않는다.
    - `@Bean`으로 등록되어 있는 스프링 빈을 스프링 컨테이너에서 관리하지 않는다.
- 큰 고민 하지말고 설정 정보에는 `@Configuration`을 사용하자

## 6. 컨포넌트 스캔
### 컴포넌트 스캔과 의존관계 자동 주입

- 스프링 설정 정보가 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능이 있다
- 의존관계도 자동으로 주입해주는 `@Autowired`라는 기능도 제공한다.
- `@ComponentScan`과 `@Configuration`어노테이션 사용
- `@ComponentScan(excludeFilters = @ComponentScan.Filter(type = FiltetType.ANNOTATION, classes = Configuration.class))`필터를 통해 자동으로 등록하지 않을것을 지정
- 컴포넌트 스캔은 이름 그대로 `@Componet`어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.
- `@Autowired`는 필요한 객체를 찾아서 의존관계를 자동으로 주입해준다.
- `@CompnentScan`과 `@Autowired`테스트
- 로그를 살펴보면 컴포넌트 스캔과 자동의존관계 주입에 따른 설정이 나타난다.
- 컴포넌트 스캔 작동 방식
  - 빈 이름 기본 전략
  - 빈 이름 직접 지명
- 자동 의존관계 주입 작동 방식
  - 기본 조회 전략은 타입이 같은 빈을 찾아서 주입한다.
    - 충돌문제는 어떻게 처리될지 생각해보자
    - `@getBean(MemberRepository.class)`와 동일하다고 이해하면 쉽다.
  - 생성자의 파라미터가 많아도 다 찾아서 자동으로 주입한다.

### 탐색 위치

```java
@ComponentScan(
    basePackages = "hello.core", "hello.service"
    ...
)
public class AutoAppConfig {
    ...
}
```
- 필요한 위치부터 탐색하도록 시작 위치를 지정할 수 있다.
- `basePackages`: 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.
- 여러 시작 위치를 지정할 수도 있다.
- `basePackageClasses`: 지정한 클래스의 패키지를 탐색 위치로 지정
- 지정하지 않았을때는? `@ComponentScan`이 붙은 클래스의 패키지를 기준으로 탐색
- 위치를 지정하지 말고, 설정정보가 있는 클래스를 프로젝트 최상단에 두는것을 권장한다.

### 컴포넌트 스캔 기본 대상
- `@Component`: 컴포넌트 스캔에서 사용
- `@Controller`: 스프링 MVC 컨트롤러에서 사용
- `@Service`: 스프링 비즈니스 로직에서 사용
- `@Repository`: 스프링 데이터 접근 계층에서 사용
- `@Configuration`: 스프링 설정 정보에서 사용

### 필터
- 컴포넌트 스캔 대상 제외
- 컴포넌트 스캔 대상 지정
- 필터 타입 5가지
  - ANNOTATION: 기본값, 어노테이션을 인식해서 동작
  - ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작
  - ASPECTJ: AspectJ 패턴 사용
  - REGEX: 정규 표현식
  - CUSTOM: `TypeFilter`라는 인터페이스를 구현해서 처리
- `excludeFilter`는 여러가지 이유로 간혹 사용할 때가 있지만 자주 사용되지는 않는다.
- `includeFilter`는 사용할 일이 거의 없다

### 중복 등록
- 자동 빈 등록과 자동 빈 등록 중복
- 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생시킨다.
- `BeanDefinitionStoreException` 예외발생
- 수동 빈 등록과 자동 빈 등록 중복
- 예전에는 수동 빈이 우선권을 가졌으나, 지금은 오류가 발생한다.

## 7. 다양한 의존관계 주입 방법

### 생성자 주입
- 생성자를 통해서 의존관계를 주입하는 방법
- 생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
- 불편, 필수 의존관계에 사용
- 생성자가 딱 1개만 있으면 `@Autowired`를 생략할 수 있다.(물론 스프링 빈에만 해당한다.)

### 수정자 주입
- `setter`라 불리는 필드의 값을 변경하는 수정자 메서드를 통해 의존관계를 주입하는 방법
- 선택, 변경 가능성이 있는 의존관계에 사용
- `@Autowired`의 기본 동작은 주입할 대상이 없으면 오류 발생
- 주입할 대상 없이 동작하려면, `@Autowired(required = false)`로 지정하면 된다.

### 필드 주입
- 필드에 바로 주입하는 방식
- 코드가 간결해지지만 외부에서 변경이 불가능하여 테스트하기 너무 힏들다.
- 사용하지 않는것이 좋다.(DI프레임워크가 없으면 아무것도 할수가 없다.)
- 예외적으로 테스트 코드에서는 사용해도 된다.

### 일반 메서드 주입
- 일반 메서드에서 주입 받는것이 가능하다.
- 일반적으로 잘 사용하지 않는다.

### 옵션 처리
- 주입할 스프링 빈이 없어도 동작해야 할 때가 있다.
- 그냥 `@Autowired`만 사용하면 `required`옵션의 기본값이 `true`로 되어 있어서 자동 주입 대상이 없으면 오류 발생
- 자동 주입 대상을 옵션으로 처리하는 방법
  - `@Autowired(required = false)`: 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 되지 않는다.
  - `org.springframeword.lang.@Nullalble`: 자동 주입할 대상이 없으면 null이 입력, 생성자 주입에서 특정 필드에 적용해서 사용 가능
  - `Optional<>`: 자동 주입 대상이 없으면 `Optional.empty`가 입력된다.

### 생성자 주입을 선택하라!
- 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료 시점까지 의존관계를 변경할 일이 없다.
- 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다. (불변)
- 수정자 주입을 사용하면, `setter`를 `public`으로 열어두어야한다.(누군가 실수로 변경할 수도 있고, 변경하면 안되는 메서드를 열어두는 것은 좋지 않다.)
- 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므르 불변하게 설계 가능
- 필요한 의존관계를 누락할 가능성이 적어진다.
- `final`키워드를 사용할 수 있다.
- 항상 생성자 주입을 선택하는것이 좋고, 옵션으로 수정자 주입을 사용하자.

### 롬복과 최신 트랜드
- `getter`, `setter`등 구현해야할 메소드를 어노테이션으로 쉽고 간단하게 사용할 수 있게 해주는 라이브러리
- 자바의 어노테이션 프로세서라는 기능을 이용해서 컴파일 시점에 생성자 코드를 자동으로 생성해준다.
- `@RequiredArgsConstructor`: `final`을 기준으로 생성자를 만들어주는 롬복이 제공해주는 어노테이션

### 조회 빈이 2개 이상 - 문제
- 자동의존관계 주입 시 조회되는 빈이 2개 이상일때 문제가 발생한다.
- `@Autowired`는 type으로 조회를 한다.
- 같은 type이 두개 있으면 중복되는 문제가 발생
- `NoUniqueBeanDefinitionException`오류가 발생한다.

### 조회 빈이 2개 이상 - 해결
- `@Autowired`빈 이름으로 매칭: 처음에는 타입 매칭을 시도하고 같은 타입의 빈이 있으면 필드 이름 또는 파라미터 이름으로 빈 이름을 추가 매칭한다.
- `@Quilifier`는 `@Quilifier`끼리 매칭: 추가 구분자를 붙여주는 방법
- `@Primay`사용: 우선순위를 지정하는 방법
- `@Primay`를 주로 사용한다.

### 커스텀 어노테이션
- `@Qualifier`좀 더 사용하기 좋게 만드는 어노테이션을 만들어보자.
- 어노테이션에는 상속이라는 개념이 없다, 여러 어노테이션을 모아 사용하는 기능은 스프링이 제공하는 기능이다.
- 무분별하게 재정의 해서 사용하는것은 좋지 않다.

### 조회한 빈이 모두 필요할때
- 의도적으로 해당 타입의 스프링 빈이 다 필요한 경우가 있다.
- 동적으로 빈을 선택해야 할때 사용하면 편리하다
- 코드를 천천히 보면서 다시한번 이해하기

### 자동 빈 등록
- 편리한 자동 기능을 기본으로 사용하자
- 관리할 빈이 많아지면서 설정 정보가 커지면 설정 정보를 관리하는 것 자체가 부담
- `@Component`만 붙이면 될 일을 객체 생성 하고 `@Bean`등록 그리고 주입할 대상을 일일이 적어주는것 이것이 참 번거로운 일이다.
- 자동 빈 등록을 사용해서 OCP와 DIP를 모두 지킬 수 있다.
- 업무 로직 빈: 웹을 지원하는 컨트롤러, 서비스, 리포지토리 등이 모두 업무 로직, 보통 비즈니스 요구사항을 개발할 때 추가, 변경된다.
- 업루 로직은 숫자도 많고 유사한 패턴을 가지고 있어 자동기능을 사용하는 것이 좋다

### 수동 빈 등록
- 기술 지원 빈: 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다.
- 기술 지원은 업무 로직과 비교했을때 수가 매우 적고 문제 발생 시 문제가 잘 들어나지 않기 때문에 수동 빈 등록을 사용해서 명확하게 들어내는 것이 좋다.
- 비즈니스 로직중에서 다형성을 적극 활용할때는 수동으로 빈을 등록하고 설정 정보를 한눈에 파악할 수 있게 하는것이 좀 더 좋다.

## 8. 빈 생명주기 콜백

### 빈 생명주기 콜백
- 간단하게 외부 네트워크에 미리 연결하는 객체를 하나 생성한다고 가정
- 스프링 빈의 간단한 라이프사이클
  - 객체생성 -> 의존관계 주입
- 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해 초기화 시점을 알려주는 다양한 기능을 제공
- 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다. 따라서 안전하게 종료 작업을 진행할 수 있다.
- 스프링 빈의 이벤트 라이프사이클
  - 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료

### 인터페이스 InitializingBean, DisposableBean
- `afterPropertiesSet()`: 의존관계 주입이 끝난 후 초기화 준비가 끝났을때 호출
- `destroy()`: 소멸전에 호출
- 단점
  - 스프링 전용 인터페이스이다, 해당 코드가 스프링 전용 인터페이스에 의존한다.
  - 초기화, 소명 메서드의 이름을 변경할 수 없다.
  - 내가 코드를 고칠수 없는 외부 라이브러리에는 적용이 불가능하다.
- 스프링 초창기에 사용하던 방식 지금은 거의 사용하지 않는다.

### 빈 등록 초기화, 소멸 메소드
- 설정 정보에 `@Bean(initMethod = "init", destroyMethod = "close")`처럼 초기화, 소멸 메소드를 지정할 수 있다.
- 메소드의 이름을 자유롭게 지정할 수 있다.
- 스프링에 의존적이지 않다.
- 외부 라이브러리에도 적용 가능하다.(가장 큰 장점)
- `@Bean의 destroyMethod`에는 기본값이 `(inferred)(추론)`으로 등록되어 있으며, 이 추론 기능은 `close`, `shutdown`이라는 이름의 메서드를 자동으로 호출해준다.
- 따라서 종료 메소드의 이름이 `close`또는 `shutdown`이면 따로 종료 메서드는 적지 않아도 잘 작동한다.
- 이 방법도 거의 사용하지 않는다.
- 단 외부 라이브러리에 적용할때는 이걸 사용해야한다.

### 어노테이션 @PostConstruct, @PreDestory
- 초기화 메서드에 `@PostConstruct`어노테이션을 붙이면 끝
- 소멸 메서드에 `@PreDestroy`어노테이션을 붙이면 끝
- 그냥 이 방법을 사용하면 된다.
- javax패키지(자바표준) 안에 있는 어노테이션으로 스프링에 종속적인 기술이 아니여서, 스프링이 아닌 다른 컨테이너에서도 동작한다.
- 외부 라이브러리에 적용이 안된다.. 외부에 적용이 필요하면 `@Bean`기능을 사용하자.

## 9. 빈 스코프

### 빈 스코프란?
- 빈이 존재할 수 있는 범위를 뜻한다.
- 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프.
- 프로토타입: 스프링 컨테이너가 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 그 이후로는 관리되지 않는 매우 짧은 범위의 스코프.
- 웹 관련 스코프
  - request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
  - session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
  - application: 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프

### 프로토타입 스코프
- 프로토타입 스코프를 스프링 컨테이너에서 조회하면 항상 새로운 인스턴스를 생성해서 반환한다.
- 스프링 컨테이너는 프로토타입 스코프의 빈을 컨테이너에 요청했을때 빈을 생성하고 필요한 의존관계를 주입한 후 반환 그 후에 관리 하지 않는다.
- 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.
- 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리
- 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은(호출한) 클라이언트에 있다.
- `@PreDestroy`같은 종료 메서드가 호출되지 않는다.

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
- 싱글톤 빈 안에서 프로토타입 빈을 주입 받으면 주입 시점에서 생성된 프로토타입 빈을 호출 시 마다 새롭게 생성하는 것이 아닌 생성된 것을 공용으로 사용한다.
- 분명 프로토타입으로 생성된 빈이지만 싱글톤처럼 사용된다.
- 프로토타입 빈을 사용할 의도와는 다른 방식으로 진행되는 문제가 발생한다.
- 로직 수행 시 마다 프로토타입을 주입받는 방식으로 해결 가능하지만 조금 무식한 방법이다.

### 프로토타입 스코프 - Provider로 문제 해결
- 싱글톤 빈과 프로토타입 빈을 함께 사용할 때, 어떻게 하면 사용할 때 마다 항상 새로운 프로토타입 빈을 생성할 수 있을까?
- 지정한 빈을 컨테이너에서 대신 찾아주는 DL(Dpendency Lookup) 서비스를 제공하는 것이 `ObjectProvider`이다.
  - DL: 의존관계를 외부에서 주입받는것이 아니라 직접 필요한 의존관계를 찾는것
- 스프링이 제공하는 기능을 사용하지만, 기능이 단순하기 때문에 단위테스트를 만들거나 mock 코드를 만들기 쉬워진다.
- 스프링에 의존적이지 않은 JSR-330 Provider를 사용 할 수도 있다.
  - 이 방법을 사용하려면 `javax.inject:javax.inject:1`라이브러리를 gradle에 추가해야 한다.
  - 매우 심플하지만, 기능도 심플하다.
  - 스프링에 의존적이지 않아 다른 컨테이너에도 사용 가능하다.
- 스프링을 사용하다 보면 자바 표준과 스프링이 제공하는 기능이 겹칠때가 많다 대부분 스프링이 더 다양하고 편리한 기능을 제공해주기 떄문에 스프링이 제공하는 기능을 사용하는게 좋다.

### 웹 스코프
- 웹 환경에서만 동작한다.
- 스프링이 종료 시점까지 관리해준다.(프로토타입 스코프와 다르게)
- request: HTTP 요청 하나가 들어오고 나갈때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
- session: HTTP Session과 동일한 생명주기를 가지는 스코프
- application: 서블릿 컨텍스트와 동일한 생명주기를 가지는 스코프
- websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프

### request 스코프 예제 만들기
- 웹 라이브러리 추가
- 동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구별하기 어렵다. 이때 사용하면 좋은것이 request 스코프이다.
- 스프링이 시작되고 request스코프를 주입 받는 시점에 고객의 요청이 없어 request스코프를 주입 할 수 없어 오류 발생 

### 스코프와 Provider
- 간단하게 ObjectProvider를 사용해서 해결
- `ObjectProvider`덕분에 `ObjectProvider.getObject()`를 호출하는 시점까지 request scope 빈의 생성을 지연 할 수 있다.
- `ObjectProvider.getObject()`를 호출하는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리
- `ObjectProvider.getObject()`를 `LogDemoController`, `LogDemoService`에서 각각 한번씩 따로 호출해도 같은 HTTP 요청이면 같은 스프링 빈이 반환된다.

### 스코프와 프록시
- `@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)`
- `Provider`를 사용한 것과 동일하게 작동된다.
- 적용 대상이 인터페이스가 아닌 클래스이면 `TARGET_CLASS`를 선택
- 적용 대상이 인터페이스면 `INTERFACES`를 선택
- 이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.
- 마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 결국 주의해서 사용해야한다.
- 꼭 필요한 곳에서만 최소화해서 사용하자 