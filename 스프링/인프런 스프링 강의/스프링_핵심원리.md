# 스프링 핵심원리

---

> 인프런에서 김영한님의 스프링 입문강의를 보고 요약, 정리한 글입니다.
> 
> 
> `강의 내용외에 직접 검색하고, 찾아본 내용도 함께 작성될 수 있습니다.`
> 
> > <a href = https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard>강의링크</a>
> > 

---

## 1. 객체 지향 설계와 스프링

### 역할과 구현을 분리

- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다. → 유연하고 변경에 유리
- 클라이언트는 대생의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

### 자바 언어의 다형성을 활용

- 역할 = 인터페이스
- 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행할 객체 만들기

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 할 수 있다.

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- SRP: 단일 책임 원칙(single resoinsibility principle)
- OCP: 개방-폐쇠 원칙(Open/Closed principle)
- LSP: 리스코프 치환 원칙(Liskov substitution principle)
- ISP: 인터페이스 분리 원칙(Interface segregation principle)
- DIP: 의존관계 역전 원칙(Dependency inversion principle)

### SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다.
    - 이게 참 모호하다..
    - 클 수도 있고, 작을 수도 있다.
    - 문맥과 상황에 따라 다르다.
- 변경을 기준으로 변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것이다.

### OCP 개방-폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
- 다형성을 활용해보자.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 구현과 역할을 분리

### LSP 리스코프 치환 원칙

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서, 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.

### ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.
- 자동차 인터페이스 → 운전, 정비 인터페이스로 분리
- 사용자 클라이언트 → 운전자, 정비사 클라이언트로 분리
- 정비 인터페이스가 변해도 운전자 클라이언트에 영향을 주지 않는다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP 의존관계 역전 원칙

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
- 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

## 2. 스프링 핵심 원리 이해(예제 만들기)

### 비즈니스 요구사항 - 회원

- 회원을 가입하고 조회할 수 있다.
- 회원은 일반과 VIP 두 가지 등급이 있다.
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동 할 수 있다.

### 비즈니스 요구사항 - 주문과 할인 정책

- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다.
- 할인 정책은 모든 VIP는 1000원을 하인해주는 고정 금액 할인을 적용
- 할인 정책은 변경 가능성이 높다.

### 회원 도메인 협력 관계

<img src = "https://user-images.githubusercontent.com/78953393/146864425-e47a1ff3-261b-43fc-afce-eb4a0fcdb11c.png" width="60%" height="40%">

### 회원 클래스 다이어그램

### 회원 객체 다이어그램

### 회원 도메인 개발

### 회원 도메인 실행과 테스트

- 메인 클래스를 만들어서 테스트하는것은 한계가 뚜렷하다, 테스트 코드 작성해서 테스트
- `Assertions` 를 사용(단, `org.assertj.core.api` 에 있는 Assertions를 사용)
- 테스트코드는 선택이 아닌 필수!

### 주문 도메인 역할

- 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
- 회원 조회: 할인을 위해서 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회
- 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임
- 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.
    - 실제로는 주문 데이터를 DB에 저장하지만, 지금은 단순하게 주문 결과를 반환

### 주문 도메인 전체

### 주문 클래스 다이어 그램

### 주문 객체 다이어그램

### 주문과 할인 도메인 개발

### 주문과 할인 도메인 테스트

### 설계의 문제점

- 지금까지 작성한 순수 자바코드로 이루어진 도메인 설계는 SOLID의 원칙중 OCP와 DIP를 위반하고 있다.
