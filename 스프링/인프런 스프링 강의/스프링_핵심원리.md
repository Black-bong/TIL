# 스프링 핵심원리

---

> 인프런에서 김영한님의 스프링 핵심원리 강의를 보고 요약, 정리한 글입니다.
> 
> 
> `강의 내용외에 직접 검색하고, 찾아본 내용도 함께 작성될 수 있습니다.`
> 
> > 출처: <a href = https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard>강의링크</a>
> > 

---

## 1. 객체 지향 설계와 스프링

### 역할과 구현을 분리

- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다. → 유연하고 변경에 유리
- 클라이언트는 대생의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

### 자바 언어의 다형성을 활용

- 역할 = 인터페이스
- 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행할 객체 만들기

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 할 수 있다.

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- SRP: 단일 책임 원칙(single resoinsibility principle)
- OCP: 개방-폐쇠 원칙(Open/Closed principle)
- LSP: 리스코프 치환 원칙(Liskov substitution principle)
- ISP: 인터페이스 분리 원칙(Interface segregation principle)
- DIP: 의존관계 역전 원칙(Dependency inversion principle)

### SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다.
    - 이게 참 모호하다..
    - 클 수도 있고, 작을 수도 있다.
    - 문맥과 상황에 따라 다르다.
- 변경을 기준으로 변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것이다.

### OCP 개방-폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
- 다형성을 활용해보자.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 구현과 역할을 분리

### LSP 리스코프 치환 원칙

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서, 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.

### ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.
- 자동차 인터페이스 → 운전, 정비 인터페이스로 분리
- 사용자 클라이언트 → 운전자, 정비사 클라이언트로 분리
- 정비 인터페이스가 변해도 운전자 클라이언트에 영향을 주지 않는다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP 의존관계 역전 원칙

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
- 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

## 2. 스프링 핵심 원리 이해(예제 만들기)

### 비즈니스 요구사항 - 회원

- 회원을 가입하고 조회할 수 있다.
- 회원은 일반과 VIP 두 가지 등급이 있다.
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동 할 수 있다.

### 비즈니스 요구사항 - 주문과 할인 정책

- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다.
- 할인 정책은 모든 VIP는 1000원을 하인해주는 고정 금액 할인을 적용
- 할인 정책은 변경 가능성이 높다.

### 회원 도메인 협력 관계

<img src = "https://user-images.githubusercontent.com/78953393/146864425-e47a1ff3-261b-43fc-afce-eb4a0fcdb11c.png" width="60%" height="40%">

### 회원 클래스 다이어그램
<img src = "https://user-images.githubusercontent.com/78953393/146955456-ae87e7bc-da3e-4230-95c7-ac417fa9acad.png" width="60%" height="40%">



### 회원 객체 다이어그램
<img src = "https://user-images.githubusercontent.com/78953393/146955462-18a47ab6-de65-47a7-998a-52cc903a647f.png" width="60%" height="40%">

### 회원 도메인 개발
- 스프링 없이 순수 자바로만 개발

```java
public class Member {
    private Long id;
    private String name;
    private Grade grade;
...
}
```

- Member 클래스

```java
public interface MemberRepository {
    void save(Member member);
    Member findById(Long memberId);
}
```

- 멤버 저장소를 인터페이스로 선언

```java
public class MemoryMemberRepository implements MemberRepository {
    private static Map<Long, Member> store = new HashMap<>();

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }

    @Override
    public Member findById(Long memberId) {
        return store.get(memberId);
    }
}
```

- 앞으로 사용될 DB가 정해지지 않았기 때문에 우선 개발을 위해 메모리 저장으로 만들고 추후 DB가 정해지면, 구현체를 변경하여 사용
- 메모리에 저장되는 저장소 생성
- 저장과 조회 기능

```java
public interface MemberService {
    void join(Member member);
    Member findMember(Long memberId);
}
```

- 멤버 서비스 인터페이스로 선언

```java
public class MemberServiceImpl implements MemberService {
    private final MemberRepository memberRepository = new MemoryMemberRepository();

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```

- 멤버 서비스 구현체
- 구현체가 하나면 인터페스명 뒤에 Impl의 붙이는것이 관례이다.
- 다형성을 잘 활용하였지만, 이게 과연 좋은 객체지향 설계에 부합할까?

### 회원 도메인 실행과 테스트

```java
public class MemberApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        Member member = new Member(1L, "memberA", Grade.VIP);
        memberService.join(member);

        Member findMember = memberService.findMember(1L);

        System.out.println("new member = " + member.getName());
        System.out.println("findMember = " + findMember.getName());
    }
}
```

- 순수한 자바로만 이루어져 있다.
- 메인 클래스를 만들어서 테스트하는것은 한계가 뚜렷하다, 테스트 코드 작성해서 테스트

```java
import org.junit.jupiter.api.Test;

public class MemberServiceTest {

    MemberService memberService = new MemberServiceImpl();

    @Test
    void join() {
        // given
        Member member = new Member(1L, "memberA", Grade.VIP);

        // when
        memberService.join(member);
        Member findMember = memberService.findMember(1L);

        // then
        Assertions.assertThat(member).isEqualTo(findMember);
    }
}
```

- `Assertions`를 사용(단, `org.assertj.core.api`에 있는 Assertions를 사용)
- 테스트코드는 선택이 아닌 필수!

### 주문 도메인 역할

<img src = "https://user-images.githubusercontent.com/78953393/146955464-ca34c0ad-bc52-479b-8961-dfe6caafbcae.png" width="60%" height="40%">

- 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
- 회원 조회: 할인을 위해서 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회
- 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임
- 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.
    - 실제로는 주문 데이터를 DB에 저장하지만, 지금은 단순하게 주문 결과를 반환

### 주문 도메인 전체

<img src = "https://user-images.githubusercontent.com/78953393/146955469-c0cf3cdf-534b-44c9-bea2-fecf7a16bd1f.png" width="60%" height="40%">

### 주문과 할인 도메인 개발

```java
public interface DiscountPolicy {
    int discount(Member member, int price)
}
```

- 할인 인터페이스

```java
public class FixDiscountPolicy implements DiscountPolicy {

    private int discountFixAmount = 1000;

    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return discountFixAmount;
        }
        return 0;
    }
}
```

- 고정 할인 구현
- 고객 등급이 VIP이면, 고정 금액을 반환해준다.

```java
public class Order {
    private Long memberId;
    private String itemName;
    private int itemPrice;
    private int discountPrice;

    public int calculatePrice() {
        return itemPrice - discountPrice;
    }
}
```

- 주문 객체
- `calculatePrice()`아이템 가격에서 할인 금액을 뺀 최종 금액을 계산하여, 반환해준다.

```java
public interface OrderService {
    Order createOrder(Long memberId, String itemName, int itemPrice);
}
```

- 오더 서비스 인터페이스
- 클라이언트에서 요청하여 생성된 주문 내역을 반환해주는 역할

```java
public class OrderServiceImpl implements OrderServie {

    private final MemberRepository = new MemoryMemberRepository();
    private final DiscountPolicy = new FixDiscountPolicy();	

    @Override
    Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = MemberRepository.findById(memberId);
        int discountPrice = DiscountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

- 주문 생성 요청 시 회원 정보 조회 후 등급에 맞는 할인 정책에 멤버와 아이템 가격을 넘겨, 할인 후의 금액을 반환받고
- 주문내역을 완성하여 반환한다.

### 주문과 할인 도메인 테스트

```java
public OrderApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        OrderService orderService = new OrderServcieImpl();

        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);		
        memberService.join(member);

        Order order = orderService.createOrder(memberId, "itemA", 10000);
        System.out.println("order=" + order);
        System.out.println("order.calculatePrice=" + order.calculatePrice());
    }
}
```

- 메인 메서드를 이용한 테스트, 물론 좋지 않은 방법

```java
public class OrderServiceTest {
    MemberService memberService = new MemberServiceImpl();
    OrderService orderService = new OrderServiceImpl();

    @Test
    void createOrder() {
        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);
        memberService.join(member);

        Order order = new Order(member, "itemA", 10000);
        Assertions.assertThat(order.getDiscountPrice()).isEquelTo(1000);
    }
}
```

- 테스트 코드 작성을 꾸준하게 연습해보자.
- 단위 테스트가 정말 중요하다.
- 여기서 단위 테스트란, 스프링이나 컨테이너의 도움없이 순수한 자바 코드하는 테스트

### 설계의 문제점

- 지금까지 작성한 순수 자바코드로 이루어진 도메인 설계는 SOLID의 원칙중 OCP와 DIP를 위반하고 있다.
- 새로운 할인 정책이 주어졌을때, 코드를 변경해보면서 DIP나 OCP가 잘 지켜졌는지 확인해보자

## 3. 스프링 핵심 원리 이해2(객체 지향 원리 적용)

### 새로운 할인 정책 개발

- VIP등급 무조건 1000원 할인에서 주문금액별 %할인으로 변경

```java
public class RateDiscountPolicy implements DiscountPolicy {

    private int discountPersent = 10;	

    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return price * discountPersent / 100;
        }
        return 0;
    }
}
```

- RateDiscountPolicy 추가

```java
class RateDsicountPolicyTest {

    DiscountPolicy discountPolicy = new RateDiscountPolicy();

    @Test
    @DisplayName("VIP는 10% 할인이 적용되어야 한다.")
    void 변동_할인_적용_테스트() {
        // given
        Member member = new Member(1L, "memberA", Grade.VIP);
        // when
        int discount = discountPolicy.discount(member, 10000);
        // then
        Assertions.assertThat(discount).isEqualTo(1000);
    }

    @Test
    @DisplayName("VIP가 아니면 할인 적용이 안되야한다..")
    void 변동_할인_적용_테스트() {
        // given
        Member member = new Member(2L, "memberBASIC", Grade.BASIC);
        // when
        int discount = discountPolicy.discount(member, 10000);
        // then
        Assertions.assertThat(discount).isEqualTo(0);
    }
}
```

- RateDiscountPolicy 테스트
- 맥 기준 `command + shift + T`단축키를 사용해서 테스트 클래스 생성
- `@DisplayName`테스트 결과창에 출력되는 메소드 명을 바꿔준다.
- 성공 테스트도 중요하지만, 실패 테스트도 꼭 만들어 봐야한다.

### 새로운 할인 정책 적용

- 새로운 할인 정책 시 발생되는 문제점

```java
public class OrderServiceImpl implements OrderServie {

    private final MemberRepository = new MemoryMemberRepository();
    // private final DiscountPolicy = new FixDiscountPolicy();
    private final DiscountPolicy = new RateDiscountPolicy();


    @Override
    Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = MemberRepository.findById(memberId);
        int discountPrice = DiscountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

- 역활과 구현을 분리: OK
- 다형성을 활용하고, 인터페이스와 구현체를 분리: OK
- OCP, DIP 같은 객체지향 설계 원칙 준수: 그렇게 보이지만 실상은 X
- DIP: 주문서비스 클라이언트(`OrderServiceImpl`)은 `DiscountPolicy` 인터페이스에 의존하면서 DIP를 지킨것 같지만,
    - 추상클래스 뿐만 아니라 구현클래스에도 의존하고 있다.
    - 추상(인터페이스)클래스 의존: `DiscountPolicy`
    - 구체(구현)클래스 의존: `RateDiscountPolicy`, `FixDiscountPolicy`
- OCP: `FixDiscountPolicy`에서 `RateDiscountPolicy`로 변경을 하는 순간, 아주 작은 부분이지만 `OrderServiceImple`의 코드가 변경되므로, OCP위반

### 문제 해결

- DIP 위반의 문제를 해결하기 위해 구체클래스가 아닌 추상클래스만 의존하도록 변경

```java
public class OrderServiceImpl implements OrderServie {

    // private final DiscountPolicy = new RateDiscountPolicy();
    private final DiscountPolicy;
...
}
```

- 구체 클래스에 의존하던 것을 없애고, 추상클래스에만 의존하도록 코드 변경
    - `private final DiscountPolicy = new RateDiscountPolicy();` → `private final DiscountPolicy;`
    - 하지만 구현클래스 없이 프로그램을 실행하면, 당연하게도 `NullPointerException`예외가 발생하고 만다.
- 그럼 어떻게 문제를 해결해야 할까?
    - 누군가 대신 구현체를 생성해서 `OrderServiceImpl`에 의존성을 주입해줘야한다.

### 관심사의 분리

```java
public class AppConfig {

    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy())
    }
    public MemberRepository memberRepository() {
        return new MemoryMemberRespository();
    }
    public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }
}
```

- `AppConfig`클래스 생성
- `AppConfig`클래스는 앱의 전반적인 설정을하고 구성하는 역할
- `AppConfig`에서 애플리케이션의 실제 동작에 필요한 구현 객체를 생성

```java
public class MemberServiceImpl implements MemberService {

    private final MemberRepository memberRepository;

    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
	...
}
```

- 생성자를 통해서 구현체가 어떤것이 쓰일것인지 확인 → 생성자 주입
- 설계 변경으로 `MemberServiceImpl`은 `MemoryMemberRepository` 를 의존하지 않는다.
- `MemberServiceImpl`입장에서는 어떤 구현 객체가 주입될지 알 수 없으며, 오직 외부(`AppConfig`)에서 결정된다.
- `MemberServiceImpl`은 의존관계에 대한 것은 외부에 맡기고 오직 로직을 실행하는 것만 신경쓰면 된다.
- 객체의 생성하고 연결하는 역할과, 실행하는 역할이 명확하게 분리되었다.

```java
public class MemberApp {
    public static void main(String[] args) {
        AppConfig appConfig = new AppConfig;
        MemberService memberService = appConfig.memberService();
        Member member = new Member(1L, "memberA", Grade.VIP);
        memberService.join(member);

      Member findMember = memberService.findMember(1L);

        System.out.println("new member = " + member.getName());
        System.out.println("findMember = " + findMember.getName());
    }
}
```

- `AppConfig`를 통해서, 의존관계를 주입받는다.

### 새로운 구조와 할인 정책 적용

- 정액할인 정책에서 정률할인 정책으로 변경해보자!

```java
public class AppConfig {
    ...
    public DiscountPolicy discountPolicy() {
        // return new FixDiscountPolicy();
        return new RateDiscountPolicy();
    }
}
```

- 새로운 할인 정책을 적용할때 사용영역의 코드는 건들필요없이 구성영역에 있는 코드만 변경해주면된다.
- `FixDiscountPolicy()` → `RateDiscountPolicy()`로 변경
- `OrderServiceImpl`안에 있는 코드는 변경할 필요 없이, `AppConfig`안에 코드만 변경해주면 끝!
- 클라이언트 코드 변경없이 앱의 기능을 확장할 수 있다. → OCP 만족!!

### 전체 흐름 정리

- 새로운 할인 정책 개발 → 다형성을 활용하여 잘 개발하였으나, 적용과정에서 OCP와 DIP를 위반
- 관심사의 분리 → 클라이언트가 두가지의 역할을 가지고 있던것을 분리
- AppConfig 리펙터링 → 구성 정보에서 역할과 구현을 명확하게 분리, 중복제거
- 새로운 구조와 할인 정책 적용 → `AppConfig`의 등장으로 애플리케이션이 크게 **사용영역**과 객체를 **구성(Configuration)하는 영역으로 분리**
- 할인 정책을 변경해도 `AppConfig`가 있는 구성 영역만 변경하면됨, 사용 영역은 변경할 필요가 없다.

### 좋은 객체 지향 설계의 5가지 원칙 적용

- SRP 단일 책임 원칙
    - 단일 책임 원칙을 따르면서 관심사를 분리
    - 구현 객체를 생성하고 연결하는 책임은 `AppConfig`가 담당
    - 클라이언트 객체는 실행하는 책임만 담당
- DIP 의존관계 역전 원칙
    - 구현 클래스와 추상 클래스에 둘 다 의존하면서 DIP원칙 위반
    - 클라이언트가 추상 클래스만 의존하도록 코드변경
    - 클라이언트 코드는 인터페이스만으로는 실행이 불가
    - `AppConfig`가 객체를 대신 생성하고 의존관계를 주입해 주면서, DIP원칙을 따르도록 문제 해결
- OCP 개방-폐쇄 원칙
    - 애플리케이션을 사용 영역과 구성 영역으로 나눔
    - 정액할인에서 정률할인으로 할인 정책을 변경했음에도 클라이언트 코드는 변경되지 않음

### IoC(Inversion of Control) 제어의 역전

- 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름이다.
- 프로그램에 대한 제어 흐름에 대한 권한은 모두 `AppConfig`가 가지고 있다. 구현 객체는 묵묵히 자신의 로직을 실행할 뿐이다.
- 심지어 구현객체의 생성 또한 `AppConfig`가 생성한다.
- 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)라고 한다.

### 프레임워크 vs 라이브러리

- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다.(ex JUnit)
- 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 라이브러리다.

### DI(Dependency Injection) 의존관계 주입

- 인터페이스만 의존, 실제 어떤 구현 객체가 사용될지는 모른다.
- 의존관계는 `정적인 클래스 의존관계` 와 실핼 시점에 결정되는 `동적인 객체(인스턴스) 의존관계` 둘을 분리해서 생각해야 한다.
    - `정적인 클래스 의존관계`: 클래스가 사용하는 import 코드만 보고 의존관계를 파악 할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석 가능하다.
    - `동적인 객체(인스턴스) 의존관계`: 애플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.
- 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경할 필요없이, 동적인 객체 인스턴스 의존관계를 변경 할 수 있다.

### IoC컨테이너, DI컨테이너

- `AppConfig`처럼 객체를 생성하고, 관리하면서 의존관계를 연결해 주는것
- 주로 DI컨테이너라 하며 어샘블러, 오브젝트 팩토리 등으로 불리기도 한다.

### 스프링으로 전환하기

- 지금까지 순수한 자바 코드만으로 DI를 적용.
- 이제는 스프링을 사용해보자!

```java
@Configuration
public class AppConfig {

    @Bean
    public MemberService memberService() {
        return new MemberServiceImpl(memberRepository());
    }
    @Bean
    public OrderService orderService() {
        return new OrderServiceImpl(memberRepository(), discountPolicy())
    }
    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRespository();
    }
    @Bean
    public DiscountPolicy discountPolicy() {
        return new FixDiscountPolicy();
    }
}
```

- `AppConfig`에서 `@Configuration`과 `@Bean`어노테이션 사용
- `import org.springframework.context.annotation.Configuration;` 이걸 사용해야한다. `import`할때는 항상 주의
- `@Configuration`: 애플리케이션을 설정하는 설정 정보에 명시해줘야한다.
- `@Bean`: key는 메서드 이름 value는 객체 인스턴스로 스프링 컨테이너에 등록(싱글톤)

```java
public class MemberApp {
    public static void main(String[] args) {
        // AppConfig appConfig = new AppConfig;
        // MemberService memberService = appConfig.memberService();

        ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);
        ac.getBean("memberService", MemberService.class);

        Member member = new Member(1L, "memberA", Grade.VIP);
        memberService.join(member);

      Member findMember = memberService.findMember(1L);

        System.out.println("new member = " + member.getName());
        System.out.println("findMember = " + findMember.getName());
    }
}
```

- `MemberApp`을 스프링을 사용하는 버전으로 변경
- `ApplicationContext`: 스프링의 모든것이 시작되는 시작점, 스프링 컨테이너라 보면 된다(모든 객체를 관리해준다)
- `AnnotationConfigApplicationContext(AppConfig.class)`: `AppConfig`에 있는 환경설정을 가지고 스프링이 `@Bean`이 붙은 객체를 스프링 컨테이너에 집어넣고 관리해준다.
- `ac.getBean("name", 타입)`: `AppConfig`에 있는 객체를 꺼내오는 역할을하며 `name`은 기본적으로 메서드 이름으로 자동 설정된다.

### 스프링 컨테이너

- `ApplicationContext`를 스프링 컨테이너라 한다.
- 기존에는 `AppConfig`를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제부턴 스프링 컨테이너를 통해서 사용한다.
- 스프링 컨테이너는 `@Configuration`이 붙은 `AppConfig`를 설정(구성) 정보로 사용한다. 여기서 `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록하며, 이렇게 등록된 객체를 스프링 빈이라고 한다.
- 스프링 빈은 메서드의 명을 스프링 빈의 이름으로 사용한다.
- `@Bean(name = "name")`형식을 사용해 스프링 빈의 이름을 변경 할 수도 있다.(특별한 경우가 아닌 이상 기본 설정이 제일 좋다)
- `.getBean()`메서드를 사용해서 스프링 컨테이너에 있는 스프링 빈을 찾아서 사용해야한다.
