# 스프링 핵심원리

---

> 인프런에서 김영한님의 스프링 핵심원리 강의를 보고 요약, 정리한 글입니다.
> 
> 
> `강의 내용외에 직접 검색하고, 찾아본 내용도 함께 작성될 수 있습니다.`
> 
> > 출처: <a href = https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard>강의링크</a>
> > 

---

## 1. 객체 지향 설계와 스프링

### 역할과 구현을 분리

- 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다. → 유연하고 변경에 유리
- 클라이언트는 대생의 역할(인터페이스)만 알면 된다.
- 클라이언트는 구현 대상의 내부 구조를 몰라도 된다.
- 클라이언트는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
- 클라이언트는 구현 대상 자체를 변경해도 영향을 받지 않는다.
- 인터페이스를 안정적으로 잘 설계하는 것이 중요하다.

### 자바 언어의 다형성을 활용

- 역할 = 인터페이스
- 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 역할과 구현을 명확히 분리
- 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행할 객체 만들기

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야한다.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 할 수 있다.

### 좋은 객체 지향 설계의 5가지 원칙(SOLID)

- SRP: 단일 책임 원칙(single resoinsibility principle)
- OCP: 개방-폐쇠 원칙(Open/Closed principle)
- LSP: 리스코프 치환 원칙(Liskov substitution principle)
- ISP: 인터페이스 분리 원칙(Interface segregation principle)
- DIP: 의존관계 역전 원칙(Dependency inversion principle)

### SRP 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다.
    - 이게 참 모호하다..
    - 클 수도 있고, 작을 수도 있다.
    - 문맥과 상황에 따라 다르다.
- 변경을 기준으로 변경이 있을때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것이다.

### OCP 개방-폐쇄 원칙

- 소프트웨어 요소는 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
- 다형성을 활용해보자.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 구현과 역할을 분리

### LSP 리스코프 치환 원칙

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서, 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.

### ISP 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나 보다 낫다.
- 자동차 인터페이스 → 운전, 정비 인터페이스로 분리
- 사용자 클라이언트 → 운전자, 정비사 클라이언트로 분리
- 정비 인터페이스가 변해도 운전자 클라이언트에 영향을 주지 않는다.
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP 의존관계 역전 원칙

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
- 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

## 2. 스프링 핵심 원리 이해(예제 만들기)

### 비즈니스 요구사항 - 회원

- 회원을 가입하고 조회할 수 있다.
- 회원은 일반과 VIP 두 가지 등급이 있다.
- 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동 할 수 있다.

### 비즈니스 요구사항 - 주문과 할인 정책

- 회원은 상품을 주문할 수 있다.
- 회원 등급에 따라 할인 정책을 적용할 수 있다.
- 할인 정책은 모든 VIP는 1000원을 하인해주는 고정 금액 할인을 적용
- 할인 정책은 변경 가능성이 높다.

### 회원 도메인 협력 관계

<img src = "https://user-images.githubusercontent.com/78953393/146864425-e47a1ff3-261b-43fc-afce-eb4a0fcdb11c.png" width="60%" height="40%">

### 회원 클래스 다이어그램
<img src = "https://user-images.githubusercontent.com/78953393/146955456-ae87e7bc-da3e-4230-95c7-ac417fa9acad.png" width="60%" height="40%">



### 회원 객체 다이어그램
<img src = "https://user-images.githubusercontent.com/78953393/146955462-18a47ab6-de65-47a7-998a-52cc903a647f.png" width="60%" height="40%">

### 회원 도메인 개발
- 스프링 없이 순수 자바로만 개발

```java
public class Member {
    private Long id;
    private String name;
    private Grade grade;
...
}
```

- Member 클래스

```java
public interface MemberRepository {
    void save(Member member);
    Member findById(Long memberId);
}
```

- 멤버 저장소를 인터페이스로 선언

```java
public class MemoryMemberRepository implements MemberRepository {
    private static Map<Long, Member> store = new HashMap<>();

    @Override
    public void save(Member member) {
        store.put(member.getId(), member);
    }

    @Override
    public Member findById(Long memberId) {
        return store.get(memberId);
    }
}
```

- 앞으로 사용될 DB가 정해지지 않았기 때문에 우선 개발을 위해 메모리 저장으로 만들고 추후 DB가 정해지면, 구현체를 변경하여 사용
- 메모리에 저장되는 저장소 생성
- 저장과 조회 기능

```java
public interface MemberService {
    void join(Member member);
    Member findMember(Long memberId);
}
```

- 멤버 서비스 인터페이스로 선언

```java
public class MemberServiceImpl implements MemberService {
    private final MemberRepository memberRepository = new MemoryMemberRepository();

    @Override
    public void join(Member member) {
        memberRepository.save(member);
    }

    @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
    }
}
```

- 멤버 서비스 구현체
- 구현체가 하나면 인터페스명 뒤에 Impl의 붙이는것이 관례이다.
- 다형성을 잘 활용하였지만, 이게 과연 좋은 객체지향 설계에 부합할까?

### 회원 도메인 실행과 테스트

```java
public class MemberApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        Member member = new Member(1L, "memberA", Grade.VIP);
        memberService.join(member);

        Member findMember = memberService.findMember(1L);

        System.out.println("new member = " + member.getName());
        System.out.println("findMember = " + findMember.getName());
    }
}
```

- 순수한 자바로만 이루어져 있다.
- 메인 클래스를 만들어서 테스트하는것은 한계가 뚜렷하다, 테스트 코드 작성해서 테스트

```java
import org.junit.jupiter.api.Test;

public class MemberServiceTest {

    MemberService memberService = new MemberServiceImpl();

    @Test
    void join() {
        // given
        Member member = new Member(1L, "memberA", Grade.VIP);

        // when
        memberService.join(member);
        Member findMember = memberService.findMember(1L);

        // then
        Assertions.assertThat(member).isEqualTo(findMember);
    }
}
```

- `Assertions`를 사용(단, `org.assertj.core.api`에 있는 Assertions를 사용)
- 테스트코드는 선택이 아닌 필수!

### 주문 도메인 역할

<img src = "https://user-images.githubusercontent.com/78953393/146955464-ca34c0ad-bc52-479b-8961-dfe6caafbcae.png" width="60%" height="40%">

- 주문 생성: 클라이언트는 주문 서비스에 주문 생성을 요청한다.
- 회원 조회: 할인을 위해서 회원 등급이 필요하다. 그래서 주문 서비스는 회원 저장소에서 회원을 조회
- 할인 적용: 주문 서비스는 회원 등급에 따른 할인 여부를 할인 정책에 위임
- 주문 결과 반환: 주문 서비스는 할인 결과를 포함한 주문 결과를 반환한다.
    - 실제로는 주문 데이터를 DB에 저장하지만, 지금은 단순하게 주문 결과를 반환

### 주문 도메인 전체

<img src = "https://user-images.githubusercontent.com/78953393/146955469-c0cf3cdf-534b-44c9-bea2-fecf7a16bd1f.png" width="60%" height="40%">

### 주문과 할인 도메인 개발

```java
public interface DiscountPolicy {
    int discount(Member member, int price)
}
```

- 할인 인터페이스

```java
public class FixDiscountPolicy implements DiscountPolicy {

    private int discountFixAmount = 1000;

    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return discountFixAmount;
        }
        return 0;
    }
}
```

- 고정 할인 구현
- 고객 등급이 VIP이면, 고정 금액을 반환해준다.

```java
public class Order {
    private Long memberId;
    private String itemName;
    private int itemPrice;
    private int discountPrice;

    public int calculatePrice() {
        return itemPrice - discountPrice;
    }
}
```

- 주문 객체
- `calculatePrice()`아이템 가격에서 할인 금액을 뺀 최종 금액을 계산하여, 반환해준다.

```java
public interface OrderService {
    Order createOrder(Long memberId, String itemName, int itemPrice);
}
```

- 오더 서비스 인터페이스
- 클라이언트에서 요청하여 생성된 주문 내역을 반환해주는 역할

```java
public class OrderServiceImpl implements OrderServie {

    private final MemberRepository = new MemoryMemberRepository();
    private final DiscountPolicy = new FixDiscountPolicy();	

    @Override
    Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = MemberRepository.findById(memberId);
        int discountPrice = DiscountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

- 주문 생성 요청 시 회원 정보 조회 후 등급에 맞는 할인 정책에 멤버와 아이템 가격을 넘겨, 할인 후의 금액을 반환받고
- 주문내역을 완성하여 반환한다.

### 주문과 할인 도메인 테스트

```java
public OrderApp {
    public static void main(String[] args) {
        MemberService memberService = new MemberServiceImpl();
        OrderService orderService = new OrderServcieImpl();

        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);		
        memberService.join(member);

        Order order = orderService.createOrder(memberId, "itemA", 10000);
        System.out.println("order=" + order);
        System.out.println("order.calculatePrice=" + order.calculatePrice());
    }
}
```

- 메인 메서드를 이용한 테스트, 물론 좋지 않은 방법

```java
public class OrderServiceTest {
    MemberService memberService = new MemberServiceImpl();
    OrderService orderService = new OrderServiceImpl();

    @Test
    void createOrder() {
        Long memberId = 1L;
        Member member = new Member(memberId, "memberA", Grade.VIP);
        memberService.join(member);

        Order order = new Order(member, "itemA", 10000);
        Assertions.assertThat(order.getDiscountPrice()).isEquelTo(1000);
    }
}
```

- 테스트 코드 작성을 꾸준하게 연습해보자.
- 단위 테스트가 정말 중요하다.
- 여기서 단위 테스트란, 스프링이나 컨테이너의 도움없이 순수한 자바 코드하는 테스트

### 설계의 문제점

- 지금까지 작성한 순수 자바코드로 이루어진 도메인 설계는 SOLID의 원칙중 OCP와 DIP를 위반하고 있다.
- 새로운 할인 정책이 주어졌을때, 코드를 변경해보면서 DIP나 OCP가 잘 지켜졌는지 확인해보자

## 3. 스프링 핵심 원리 이해2(객체 지향 원리 적용)

### 새로운 할인 정책 개발

- VIP등급 무조건 1000원 할인에서 주문금액별 %할인으로 변경

```java
public class RateDiscountPolicy implements DiscountPolicy {

    private int discountPersent = 10;	

    @Override
    public int discount(Member member, int price) {
        if (member.getGrade() == Grade.VIP) {
            return price * discountPersent / 100;
        }
        return 0;
    }
}
```

- RateDiscountPolicy 추가

```java
class RateDsicountPolicyTest {

    DiscountPolicy discountPolicy = new RateDiscountPolicy();

    @Test
    @DisplayName("VIP는 10% 할인이 적용되어야 한다.")
    void 변동_할인_적용_테스트() {
        // given
        Member member = new Member(1L, "memberA", Grade.VIP);
        // when
        int discount = discountPolicy.discount(member, 10000);
        // then
        Assertions.assertThat(discount).isEqualTo(1000);
    }

    @Test
    @DisplayName("VIP가 아니면 할인 적용이 안되야한다..")
    void 변동_할인_적용_테스트() {
        // given
        Member member = new Member(2L, "memberBASIC", Grade.BASIC);
        // when
        int discount = discountPolicy.discount(member, 10000);
        // then
        Assertions.assertThat(discount).isEqualTo(0);
    }
}
```

- RateDiscountPolicy 테스트
- 맥 기준 `command + shift + T`단축키를 사용해서 테스트 클래스 생성
- `@DisplayName`테스트 결과창에 출력되는 메소드 명을 바꿔준다.
- 성공 테스트도 중요하지만, 실패 테스트도 꼭 만들어 봐야한다.

### 새로운 할인 정책 적용

- 새로운 할인 정책 시 발생되는 문제점

```java
public class OrderServiceImpl implements OrderServie {

    private final MemberRepository = new MemoryMemberRepository();
    // private final DiscountPolicy = new FixDiscountPolicy();
    private final DiscountPolicy = new RateDiscountPolicy();


    @Override
    Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = MemberRepository.findById(memberId);
        int discountPrice = DiscountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

- 역활과 구현을 분리: OK
- 다형성을 활용하고, 인터페이스와 구현체를 분리: OK
- OCP, DIP 같은 객체지향 설계 원칙 준수: 그렇게 보이지만 실상은 X
- DIP: 주문서비스 클라이언트(`OrderServiceImpl`)은 `DiscountPolicy` 인터페이스에 의존하면서 DIP를 지킨것 같지만,
    - 추상클래스 뿐만 아니라 구현클래스에도 의존하고 있다.
    - 추상(인터페이스)클래스 의존: `DiscountPolicy`
    - 구체(구현)클래스 의존: `RateDiscountPolicy`, `FixDiscountPolicy`
- OCP: `FixDiscountPolicy`에서 `RateDiscountPolicy`로 변경을 하는 순간, 아주 작은 부분이지만 `OrderServiceImple`의 코드가 변경되므로, OCP위반

### 문제 해결

- DIP 위반의 문제를 해결하기 위해 구체클래스가 아닌 추상클래스만 의존하도록 변경

```java
public class OrderServiceImpl implements OrderServie {

    // private final DiscountPolicy = new RateDiscountPolicy();
    private final DiscountPolicy;
...
}
```

- 구체 클래스에 의존하던 것을 없애고, 추상클래스에만 의존하도록 코드 변경
    - `private final DiscountPolicy = new RateDiscountPolicy();` → `private final DiscountPolicy;`
    - 하지만 구현클래스 없이 프로그램을 실행하면, 당연하게도 `NullPointerException`예외가 발생하고 만다.
- 그럼 어떻게 문제를 해결해야 할까?
    - 누군가 대신 구현체를 생성해서 `OrderServiceImpl`에 의존성을 주입해줘야한다.
