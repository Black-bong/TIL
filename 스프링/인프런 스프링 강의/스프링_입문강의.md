# 스프링 입문강의
---
>인프런에서 김영한님의 스프링 입문강의를 보고 요약, 정리한 글입니다.
>
> `강의 내용외에 직접 검색하고, 찾아본 내용도 함께 작성될 수 있습니다.`
>>출처: https://www.inflearn.com/course/스프링-핵심-원리-기본편/dashboard
---
# 1.프로젝트 환경설정

## 라이브러리
### 웹관련
- tomcat
    - 톰캣(웹서버)
- webmvc
    - 스트링 웹 mvc
    - https://docs.spring.io/spring-boot/docs/2.6.2-SNAPSHOT/reference/htmlsingle/#web.servlet.spring-mvc
    - Spring docs을 보면 간단한 예제와 더욱 자세한 설명을 볼 수 있는 링크가 있으니 꼭 한번 보자
### 로그관련
- logback
    - 성능도 좋고 여러 지원하는 기능이 많아 요즘 많이 사용
- slf4j
    - 구현체의 전환을 통해 다른 로깅 프레임워크로 전환이 쉽다.
### 테스트관련
- junit5
    - 대부분 이걸사용
    - https://junit.org/junit5/docs/current/user-guide/
- mockito
    - 목 라이브러리
    - Java 용 오픈 소스 테스트 프레임 워크
## View설정
### Welcome Page
- `static/index.html` 을 올려두면 Welcom page 기능이 작동되어 index.html을 화면에 띄어준다.
- [https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.welcome-page](https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.welcome-page)
### thymeleaf
- 템플릿 엔진
- [https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.template-engines](https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.template-engines)

## controller
- webapplication에서의 첫번째 진입점
- `@Controller` 어노테이션 사용
    
    ```java
    @Controller
    public class HelloController {
    
      @GetMapping("hello")
      public String hello(Model model) {
        model.addAttribute("data", "hello!");
        return	"hello";
      }
    }
    ```   
    - 컨트롤러에서 리턴 값으로 문자를 반환하면 뷰 리졸버가 화면을 찾아서 처리한다.
    - `model.addAttribute("data", "hello")` → 모델의 data값으로 hello!를 추가
## 빌드하고 실행하기
1. 콘솔로 이동
2. `./gralew build` 입력
3. `cd build/libs` 입력
4. `java -jar hello-spring-0.0.1-SNAPSHOT.jar` 입력
5. 실행 확인
6. 잘안되면 `./gradlew clean build` 입력해서 `build`를 초기화하고 다시 처음부터 해보기
# 2.스프링 웹 개발 기초
### 정적컨텐츠
- 내장 톰켓서버에서 스프링 컨테이너에 `.html` 관련 컨트롤러가 있는지 확인 후 없으면 `resources/static`안에서 찾아보고 있으면 그대로 반환
- [https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.static-content](https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.static-content)
### MVC와 템플릿 엔진
- Controller
- Model    
    ```java
    @Controller
    public class HelloController {
    
      @GetMapping("hello")
      public String hello(Model model) {
        model.addAttribute("data", "hello!");
        return	"hello";
      }
      @GetMapping("hello-mvc")
      public String helloMvc(@RequestParam("name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello-template"
      }
    }
    ```    
- View   
    `resources/template/hellp-template.html`    
    ```html
    <html xmlns:th="http://www.thymeleaf.org">
      <body>
        <p th:text="'hello ' + ${name}">hello! empty</p>
      </body>
    </html>
    ...
    ```  
    - parameter(ex:localhost:8080/hello-mvc?name=Spring!!)로 name을 넘겨주면 model에서(name:spring) viewResolver로 값을 넘겨 화면 출력
    - 화면 출력은 Thymeleaf 템플릿 엔진이 처리
### API
```java
@Controller
public class HelloController {

    @GetMapping("hello-string")
    @ResponseBody
    public String helloString(@RequestParam("name") String name) {
        return "hello" + name; // "hello spring"
    }
}
```
- `@ResponseBody` : HTTP통신 프로토콜 응답BODY부에 직접 데이터를 넣어주겠다는 표시의 어노테이션
- view이런거 없이 return 되는 문자 그대로 출력됨.
- 이대로 사용되는 일은 거의 없다.
```java
@Controller
public class HelloController {

    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name) {
        Hello hello = new Hello();
        hello.setName(name);
        return hello;
    }

    static class Hello {
        private String name;

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
}
```
- 리턴을 문자가 아닌 객체를 리턴하였다.
- 문자를 리턴하면 문자 그대로 출력되고, 소스를 봐도 문자만 출력되지만 객체를 리턴 할 경우 json형식으로 출력되지만.
- `{"name":"spring!!!!!!"}` 키`:`값 형태의 json형식
- spring프로젝트에서는 json형식으로 반환하는것이 디폴트, 다른형식으로 변경은 가능하다(xml등등)
### `@ResponseBody` 사용원리
- HTTP의 BODY에 문자 내용을 직접 반환
- `viewResolver` 대신에 `HttpMessageConverter` 가 동작한다.
- 기본 문자처리: `StringHttpMessageConverter` 가 동작.
- 기본 객체처리: `MappingJackson2HttpMessageConverter` 가 동작.
    - Jackson2: 객체를 json으로 변환해주는 대표적인 라이브러리중 하나(스프링 기본 설정)
    - [https://docs.spring.io/spring-boot/docs/2.6.2-SNAPSHOT/reference/htmlsingle/#features.json.jackson](https://docs.spring.io/spring-boot/docs/2.6.2-SNAPSHOT/reference/htmlsingle/#features.json.jackson)

## 3. 회원 관리 예제

## 비즈니스 요구사항

- 데이터: 회원ID, 이름
- 기능: 회원 등록, 조회
- 아직 데이터 저장소가 선정되지 않음(가상의 시나리오)

### 일반적인 웹 애플리케이션 계층 구조

- Controller: 웹 MVC의 컨트롤러 역할
- Service: 핵심 비즈니스 로직 구현
- Repository: DB에 접근, 도메인 객체를 DB에 저장하고 관리
- Domain: 비즈니스 도메인 객체(ex: 회원, 주문, 쿠폰 등등 주로 DB에 저장하고 관리된다)

### 회원 도메인과 리포지토리 만들기

- Member객체의 값을 꺼내거나, 변경할때 get, set을 사용하는 것은 좋은 방식이 아니다. 이점에 대해 좀 더 고민해 봐야겠다.

```java
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
}
```

- `@GeneratedValue` : Entity에서 PK를 지정해 줄때 사용되는 어노테이션 `@Id` 와 같이 사용
- `(stratedy = GenerationType.IDENTITY)` : id값 설정을 DB에 위임, AOTUINCREMENT와 동일하다.

```java
public interface MemberRepository {
    Member save(Member member);
    Optional<Member> findById(Long id);
    Optional<Member> findByName(String name);
    List<Member> findAll();
}
```

- 추가적으로 사용할 DB가 아직 정해지지 않았고, 또 변경 가능성이 있어 Repository를 인터페이스로 만들고 사용하는 DB에 맞게 구현하여 사용
- findById와 findByName은 null값이 존재할 수 있기 떄문에 Optional로 반환한다.

```java
public class MemoryMemberRepository implements MemberRepository {
    private static Map<Long, member> store = new HashMap<>();
    private static long sequence = 0L;

    @Override
    public Member save(Member member) {
        member.setId(++sequence);
        store.put(member.getId(), member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        return Optional.ofNullable(store.get(id)); // get을 사용한 직접적인 return 방식은 좋지 않다.
    }

    @Override
    public Optional<Member> findByName(String name) {
        return store.values().stream().filter(member -> member.getName().equals(name)).findAny();
    }

    @Override
    public List<Member> findAll() {
        return new ArrayList<>(store.values());
    }

    // test할때 사용
    public void clearStore() {
        store.clear();
    }
}
```

- 여기서는 우선 어떤 DB를 사용할지 정하지 않아 Repository에 저장될때마다 직접 id값을 지정해 준다.
- Memoey에 저장될때 사용하는 Repository를 생성

### 회원 리포지토리 테스트 케이스 작성

- 개발한 기능을 실행하여 테스트 할 때 준비와 실행이 오래걸리고, 반복실행이 어려우며, 여러 테스트를 한번에 실행하기 어렵다는 단점이 있어 자바에서는 JUnit이라는 프레임워크를 사용 이런 번거로움의 문제점을 해결
- 테스트는 순서가 보장이 안된다.
- 테스트는 순서에 의존적으로 설계해서는 안된다.

```java
import static org.assertj.core.api.Assertions.assertThat;
```

- Assertions.assertThat을 static import하여 assertThat으로 사용

```java
@AfterEach
public void afterEach() {
    memberRepository.clearStore();
}
```

- `@afterEach` 콜백 메소드로 지정(어떠한 메서드의 작동이 종료되면 실행되게 만들어줌)
- 테스트 종료 시 공용데이터는 깔끔하게 지워줘야 한다.

```java
@Test
void save() {
    Member member = new Member();
    member.setName("spring");

    memberRepository.save(member);
    Member result = memberRepository.findById(member.getId)).get();
    assertThat(result).isEqualTo(result);
}

@Test
void findByName() {
    Member member1 = new Member();
    member1.setName("Spring1");
    memberRepository.save(member1);

    Member member2 = new Member();
    member2.setName("Spring2");
    memberRepository.save(member2);

    Member result = memberRepository.findByName(member1.getName()).get();

    assertThat(member1).isEqualTo(result);
}

@Test
void findAll() {
    Member member1 = new Member();
    member1.setName("Spring1");
    memberRepository.save(member1);

    Member member2 = new Member();
    member2.setName("Spring2");
    memberRepository.save(member2);

    List<Member> memberList = memberRepository.findAll();

    assertThat(memberList.size()).isEqualTo(2);
}
```

- Optional값을 그냥 get()으로 가져오는것은 좋지 않다.
- 하지만 테스트 코드에서는 간편하게 이런식으로 사용해도 괜찮다.

### 회원 서비스 개발

- Repository는 기계적으로 네이밍해도 괜찮다.
- Service는 비즈니스에서 사용되는 용어를 사용하는것이 좋다.(비즈니스에 의존적으로 개발)

```java
public class MemberService {

    private final MemberRepository memberRepository;

    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

- MemberService가 생성될때 외부에서 memberRepository를 주입받는다.

```java
public Long join(Member member() {
    validateDuplicateMember(member);
    memberRepository.save(member);
    return member.getId();
}
```

- 회원 가입에 성공할 경우 아이디 값을 반환(가상의 비즈니스 로직)

```java
private void validateDuplicateMember(Member member) {
    memberRepository.findByName(member.getName())
        .ifPresent(m -> {
            throw new IllegalStateException("이미 존재하는 회원입니다.");
        });
}
```

- 회원 이름이 같을 경우 가입이 불가(가상의 비즈니스 로직)
- Optional에서 어떠한 값이 null이 아닌 경우 throw를 생성한다.
- 회원 이름이 중복되는 경우 `IllegalStateException` 예외 발생

### 회원 서비스 테스트

```java
MemberService memberService;
MemoryMemberRepository memberRepository;

@BeforeEach
public void beforEach() {
    memberRepository = new MemoryMemberRepository();
    memberService = new MemberService(memberRepository);
}
```

- `@beforeEach` after의 반대 메서드가 실행 되기전 작동되게 만들어준다.
- 전역으로 객체를 생성해도 되지만, 여러곳에서 같이 쓰이는 객체를 여러곳에서 생성 할 경우 문제가 발생 될 수 있기 때문에 생성자를 통해 객체를 생성할 때 memberRepository를 주입해준다.
- 위의 방식이 바로 DI(Dependency injectio) 즉, 의존성 주입이다.

```java
@Test
void 중복_회원_예외() {
    //given
    Member member1 = new Member();
    member1.setName("spring");
    Member member2 = new Member();
    member2.setName("spring");

    //when
    memberService.join(member1);

    //then
    IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));
    assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
}
```

- 테스트 메서드의 네이밍은 한글로 만들어도 상관없다.
- `//given //when //then` 으로 나누고 이걸 기반으로 작성해보는 연습을 하고, 추후 상황에 따라 변경해보자.
- 해당 로직을 진행 했을 때 원하는 예외가 발생하는지 알아보는 테스트 코드
## 4. 스프링 빈과 의존관계

### 컴포넌트 스캔과 자동 의존관계 설정

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {
...
}
```

- 컴포넌트 스캔 방식은 `@component` 을 포함한 어노테이션을 사용하면 스프링빈으로 자동등록 되는 방식을 말한다.(`@Controller`, `@Service` 등등)

```java
@Service	
public class MemberService {

    private final MemberRepository memberRepository;

    @Autowired
    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

- `@Autowired` 스프링 컨테이너에 등록되고 스프링이 관리하는 것 중에 의존관계가 필요한것을 자동으로 주입해준다.
- `@Autowired` 를 통한 DI는 스프링빈으로 등록되어 있지 않은 객체에서는 동작하지 않는다.
- `@Autowired` 는 생성자가 1개이면, 생략가능하다.

```java
// 생성자 주입
@Controller
public class MemberController {
    private final MemberService memberService;

    @Autowired
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }
}
```

- 생성자를 통한 의존성 주입

```java
@Controller
public class MemberController {

    @Autowired
    private final MemberService memberService;
}
```

- 필드 주입
- 추후 변경이 불가능하기 때문에 좋지 않은 방식

```java
@Controller
public class MemberController {
    private final MemberService memberService;

    @Autowired
    public void setMemberService(MemberService memberService) {
        this.memberService = memberService;
    }
}
```

- Setter 주입
- 아무나 접근(public)이 가능하기 때문에 좋지 않은 방식
- 의존성 주입(DI)에는 필드, setter, 생성자 주입 이렇게 3가지 방법이 있는데, 의존관계가 실행중에 동적으로 변하는 경우는 거의 없으므로 생성자 주입을 권장한다.

### 자바 코드로 직접 스프링 빈 등록하기

- 회원 서비스와 회원 리포지토리의 `@Service` , `@Repository` , `@Autowired` 어노테이션을 제거하고 진행

```java
@Configration
public class SpringConfig {

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }
}
...
```

- `@Bean` 스프링 빈에 등록하도록 지정해주는 어노테이션
- 실무에서는 주로 정형화된 컨트롤러, 서비스, 리포지토리 같은 코드는 컴포넌트 스캔을 사용하고, 상황에 따라 구현 클래스를 변경해야하는 것들이나 정형화 되지 않은것은 설정을 통해 빈에 등록한다.

## 5. 웹 MVC 개발

### 회원 등록 기능

```java
@Controller
public class MemberController {
...
    @GetMapping("/members/new")
    public String createForm() {
        return "member/createMemberForm";
    }
...
}
```

- localhost8080/members/new를 입력하면 해당 URL의 HTML파일을 반환해준다.

`resources/templates/members/createMemberForm.html`

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<body>
<div class="container">
    <form acton="/members/new" method="post">
        <div class="form-group">
            <label for="name">이름</label>
            <input type="text" id="name" name="name" placeholder="이름을 입력하세요">
        </div>
        <button type="summit">등록</button>
    </form>
</div>
</body>
</html>
```

- 멤버의 이름을 입력받는 HTML파일(멤버 등록 화면)
- input태그에서 받은 name을 post방식으로 넘겨준다.

```java
public class MemberForm {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

- 위에서 입력된 name이 이곳에서 매칭되면서 값이 들어온다.
- 스프링이 넘어온 name을 set을 사용해 이곳에 넣어준다.

```java
@Controller
public class MemberController {
...
    @PostMapping("/members/new")
    public String create(MemberForm form) {
        Member member = new Member();
        member.setName(form.getName());

        memberService.join(member);

        return "redirect:/";
    }
...
}
```

- 데이터를 조회할때는 주로 get을, 폼같은곳에 넣어서 데이터를 전달할때는 주로 post를 사용

### 회원 조회 기능

```java
@Controller
public class MemberController {
...
    @GetMapping("/members")
    public String list(Model model) {
        List<Member> members = memberService.findMembers();
        model.addAttribute("members", members);

        return "members/memberList";
    }
...
}
```

- get방식으로 저장되어있는 member를 반환해주는 메소드

`resources/templates/members/memberList.html`

```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">
<body>

<div class="container">
    <div>
        <table>
            <thead>
            <tr>
                <th>#</th>
                <th>이름</th>
            </tr>
            </thead>
            <tbody>
            <tr th:each="member : ${members}">
                <td th:text="${member.id}"></td>
                <td th:text="${member.name}"></td>
                <td th:if="${member.name}"></td>
            </tr>
            </tbody>
        </table>
    </div>
</div>
</body>
</html>
```

- `${...}` : 모델안에서 무언가를 꺼낼때 사용 thymeleaf 문법
- `th:each` : java forEach와 같은 기능

## 6. 스프링 DB 접근 기술

### H2 DB 설치

```sql
CREATE TABLE MEMBER (
    ID BIGINT GENERATED BY DEFAULT AS IDENTITY,
    NAME VARCHAR(255),
    PRIMARY KEY(ID)
);
```

- `AUTO_INCREMENT` == `GENERATED BY DEFAULT AS IDENTITY`

### 순수 JDBC

- 고대의 사용하던 기술 ㅋㅋ
- 그냥 이런게 있었더라 하고 넘기기
- 필요할때 찾아보면 된다.

`@resources/application.properties`

```
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
```

- DB접속정보 입력
- 스프링이 전부 해주기 때문에 경로와 DB이름만 넣어주면 된다.

### 스프링 통합 테스트

- 테스트 코드 작성 할 때는 의존성 주입은 그냥 필드 주입으로 편리하게 하는것이 좋다.
- `@SpringBootTest`
- `@Transactional` 테스트 케이스에 작성 시  테스트를 진행하면서 DB에 작성된 것을 테스트 종료 시 DB에 반영되지 않도록 해준다.
- 순수한 자바로만 이루어진 단위 테스트가 좋은 테스트일 확률이 높다, 가급적이면 단위 테스트를 진행하자.

### 스프링 JDBC Template

- 순수 JDBC에서 사용되는 반복적인 코드를 대부분 제거해주지만, SQL 쿼리는 직접 작성해야 한다.
- 환경설정은 JDBC와 동일하다.
- RowMapper?

### JPA

- 기존의 반복 코드는 물론이고, 기본적인 SQL도 JPA가 직접 만들어서 실행

```java
...
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    reuntimeOnly 'com.h2database:h2'
}
...
```

- build.gradle파일에 JPA, H2 데이터베이스 관련 라이브러리 추가
- `@Entity` JPA가 관리하는 Entity라는것을 명시하는 어노테이션
- JPA는 자바진영의 표준 인터페이스고, 구현은 hibernate를 사용
- JPA는 EntityManager로 모든걸 동작
- JPA 라이브러리를 사용하면 EntityManager를 자동으로 생성해준다.
- JPA로 데이터를 변경할때는 무조건 `@Transactional` 을 사용해야한다.
- `@PersistenceContext` 원래 스팩에서는 이걸 필드 주입형태로 작성하여, DI를 해줘야한다고 하는데 `@Autowired` 를 사용한 생성자를 통한 주입을해도 되긴한다.

### 스프링 데이터 JPA

- JPA공부 후에 스프링 데이터 JPA를 공부 해야한다.
- 써보니 왜 이것부터 공부하면 안되는지 알겠다.. 원리도 모르고 그냥 갔다 쓰겠넹..
- 기본적인 CRUD는 아무것도 안해도 그냥 제공
- 통용적인것 외에는 규칙에 맞게 명시해주면 JPQL을 작성하여 동작해준다.
- 간단한건 메서드 이름만으로도 JPQL이 작성 가능하다.
    - Optional<Member> findByName(String name) → SELECT m FROM member m WHERE name = ?;
- 페이징 기능도 자동으로 제공

## 7. AOP

### AOP가 필요한 상황

- 모든 메소드의 호출 시간을 측정하고 싶을때
- 공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern)
- 회원 가입 시간, 회원 조회 시간을 측정하고 싶을때

### AOP 적용

- AOP: Aspect Oriented Programming
- 공통 관심 사항과 핵심 관심 사항을 분리
- 시간 측정 로직을 하나에 묶어서 원하는 공통 관심 사항에 적용
- `@Aspect` AOP 사용 시 필요한 어노테이션
- 메뉴얼대로 사용하면 된다.
- 스프링 빈에 직접 또는 `@Component` 어노테이션을 사용해서 등록(직접 등록하는 것이 좀 더 좋다.)
