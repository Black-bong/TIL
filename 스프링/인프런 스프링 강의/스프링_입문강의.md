# 스프링 입문강의
---
>인프런에서 김영한님의 스프링 입문강의를 보고 요약, 정리한 글입니다.
>
> `강의 내용외에 직접 검색하고, 찾아본 내용도 함께 작성될 수 있습니다.`
>>출처: https://www.inflearn.com/course/스프링-핵심-원리-기본편/dashboard
---
# 1.프로젝트 환경설정

## 라이브러리
### 웹관련
- tomcat
    - 톰캣(웹서버)
- webmvc
    - 스트링 웹 mvc
    - https://docs.spring.io/spring-boot/docs/2.6.2-SNAPSHOT/reference/htmlsingle/#web.servlet.spring-mvc
    - Spring docs을 보면 간단한 예제와 더욱 자세한 설명을 볼 수 있는 링크가 있으니 꼭 한번 보자
### 로그관련
- logback
    - 성능도 좋고 여러 지원하는 기능이 많아 요즘 많이 사용
- slf4j
    - 구현체의 전환을 통해 다른 로깅 프레임워크로 전환이 쉽다.
### 테스트관련
- junit5
    - 대부분 이걸사용
    - https://junit.org/junit5/docs/current/user-guide/
- mockito
    - 목 라이브러리
    - Java 용 오픈 소스 테스트 프레임 워크
## View설정
### Welcome Page
- `static/index.html` 을 올려두면 Welcom page 기능이 작동되어 index.html을 화면에 띄어준다.
- [https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.welcome-page](https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.welcome-page)
### thymeleaf
- 템플릿 엔진
- [https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.template-engines](https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.template-engines)

## controller
- webapplication에서의 첫번째 진입점
- `@Controller` 어노테이션 사용
    
    ```java
    @Controller
    public class HelloController {
    
      @GetMapping("hello")
      public String hello(Model model) {
        model.addAttribute("data", "hello!");
        return	"hello";
      }
    }
    ```   
    - 컨트롤러에서 리턴 값으로 문자를 반환하면 뷰 리졸버가 화면을 찾아서 처리한다.
    - `model.addAttribute("data", "hello")` → 모델의 data값으로 hello!를 추가
## 빌드하고 실행하기
1. 콘솔로 이동
2. `./gralew build` 입력
3. `cd build/libs` 입력
4. `java -jar hello-spring-0.0.1-SNAPSHOT.jar` 입력
5. 실행 확인
6. 잘안되면 `./gradlew clean build` 입력해서 `build`를 초기화하고 다시 처음부터 해보기
# 2.스프링 웹 개발 기초
### 정적컨텐츠
- 내장 톰켓서버에서 스프링 컨테이너에 `.html` 관련 컨트롤러가 있는지 확인 후 없으면 `resources/static`안에서 찾아보고 있으면 그대로 반환
- [https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.static-content](https://docs.spring.io/spring-boot/docs/2.6.1/reference/htmlsingle/#web.servlet.spring-mvc.static-content)
### MVC와 템플릿 엔진
- Controller
- Model    
    ```java
    @Controller
    public class HelloController {
    
      @GetMapping("hello")
      public String hello(Model model) {
        model.addAttribute("data", "hello!");
        return	"hello";
      }
      @GetMapping("hello-mvc")
      public String helloMvc(@RequestParam("name") String name, Model model) {
        model.addAttribute("name", name);
        return "hello-template"
      }
    }
    ```    
- View   
    `resources/template/hellp-template.html`    
    ```html
    <html xmlns:th="http://www.thymeleaf.org">
      <body>
        <p th:text="'hello ' + ${name}">hello! empty</p>
      </body>
    </html>
    ...
    ```  
    - parameter(ex:localhost:8080/hello-mvc?name=Spring!!)로 name을 넘겨주면 model에서(name:spring) viewResolver로 값을 넘겨 화면 출력
    - 화면 출력은 Thymeleaf 템플릿 엔진이 처리
    ### API
```java
@Controller
public class HelloController {

    @GetMapping("hello-string")
    @ResponseBody
    public String helloString(@RequestParam("name") String name) {
        return "hello" + name; // "hello spring"
    }
}
```
- `@ResponseBody` : HTTP통신 프로토콜 응답BODY부에 직접 데이터를 넣어주겠다는 표시의 어노테이션
- view이런거 없이 return 되는 문자 그대로 출력됨.
- 이대로 사용되는 일은 거의 없다.
```java
@Controller
public class HelloController {

    @GetMapping("hello-api")
    @ResponseBody
    public Hello helloApi(@RequestParam("name") String name) {
        Hello hello = new Hello();
        hello.setName(name);
        return hello;
    }

    static class Hello {
        private String name;

        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
    }
}
```
- 리턴을 문자가 아닌 객체를 리턴하였다.
- 문자를 리턴하면 문자 그대로 출력되고, 소스를 봐도 문자만 출력되지만 객체를 리턴 할 경우 json형식으로 출력되지만.
- `{"name":"spring!!!!!!"}` 키`:`값 형태의 json형식
- spring프로젝트에서는 json형식으로 반환하는것이 디폴트, 다른형식으로 변경은 가능하다(xml등등)
### `@ResponseBody` 사용원리
- HTTP의 BODY에 문자 내용을 직접 반환
- `viewResolver` 대신에 `HttpMessageConverter` 가 동작한다.
- 기본 문자처리: `StringHttpMessageConverter` 가 동작.
- 기본 객체처리: `MappingJackson2HttpMessageConverter` 가 동작.
    - Jackson2: 객체를 json으로 변환해주는 대표적인 라이브러리중 하나(스프링 기본 설정)
    - [https://docs.spring.io/spring-boot/docs/2.6.2-SNAPSHOT/reference/htmlsingle/#features.json.jackson](https://docs.spring.io/spring-boot/docs/2.6.2-SNAPSHOT/reference/htmlsingle/#features.json.jackson)

## 3. 회원 관리 예제

## 비즈니스 요구사항

- 데이터: 회원ID, 이름
- 기능: 회원 등록, 조회
- 아직 데이터 저장소가 선정되지 않음(가상의 시나리오)

### 일반적인 웹 애플리케이션 계층 구조

- Controller: 웹 MVC의 컨트롤러 역할
- Service: 핵심 비즈니스 로직 구현
- Repository: DB에 접근, 도메인 객체를 DB에 저장하고 관리
- Domain: 비즈니스 도메인 객체(ex: 회원, 주문, 쿠폰 등등 주로 DB에 저장하고 관리된다)

### 회원 도메인과 리포지토리 만들기

- Member객체의 값을 꺼내거나, 변경할때 get, set을 사용하는 것은 좋은 방식이 아니다. 이점에 대해 좀 더 고민해 봐야겠다.

```java
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
}
```

- `@GeneratedValue` : Entity에서 PK를 지정해 줄때 사용되는 어노테이션 `@Id` 와 같이 사용
- `(stratedy = GenerationType.IDENTITY)` : id값 설정을 DB에 위임, AOTUINCREMENT와 동일하다.

```java
public interface MemberRepository {
    Member save(Member member);
    Optional<Member> findById(Long id);
    Optional<Member> findByName(String name);
    List<Member> findAll();
}
```

- 추가적으로 사용할 DB가 아직 정해지지 않았고, 또 변경 가능성이 있어 Repository를 인터페이스로 만들고 사용하는 DB에 맞게 구현하여 사용
- findById와 findByName은 null값이 존재할 수 있기 떄문에 Optional로 반환한다.

```java
public class MemoryMemberRepository implements MemberRepository {
    private static Map<Long, member> store = new HashMap<>();
    private static long sequence = 0L;

    @Override
    public Member save(Member member) {
        member.setId(++sequence);
        store.put(member.getId(), member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        return Optional.ofNullable(store.get(id)); // get을 사용한 직접적인 return 방식은 좋지 않다.
    }

    @Override
    public Optional<Member> findByName(String name) {
        return store.values().stream().filter(member -> member.getName().equals(name)).findAny();
    }

    @Override
    public List<Member> findAll() {
        return new ArrayList<>(store.values());
    }

    // test할때 사용
    public void clearStore() {
        store.clear();
    }
}
```

- 여기서는 우선 어떤 DB를 사용할지 정하지 않아 Repository에 저장될때마다 직접 id값을 지정해 준다.
- Memoey에 저장될때 사용하는 Repository를 생성

### 회원 리포지토리 테스트 케이스 작성

- 개발한 기능을 실행하여 테스트 할 때 준비와 실행이 오래걸리고, 반복실행이 어려우며, 여러 테스트를 한번에 실행하기 어렵다는 단점이 있어 자바에서는 JUnit이라는 프레임워크를 사용 이런 번거로움의 문제점을 해결
- 테스트는 순서가 보장이 안된다.
- 테스트는 순서에 의존적으로 설계해서는 안된다.

```java
import static org.assertj.core.api.Assertions.assertThat;
```

- Assertions.assertThat을 static import하여 assertThat으로 사용

```java
@AfterEach
public void afterEach() {
    memberRepository.clearStore();
}
```

- `@afterEach` 콜백 메소드로 지정(어떠한 메서드의 작동이 종료되면 실행되게 만들어줌)
- 테스트 종료 시 공용데이터는 깔끔하게 지워줘야 한다.

```java
@Test
void save() {
    Member member = new Member();
    member.setName("spring");

    memberRepository.save(member);
    Member result = memberRepository.findById(member.getId)).get();
    assertThat(result).isEqualTo(result);
}

@Test
void findByName() {
    Member member1 = new Member();
    member1.setName("Spring1");
    memberRepository.save(member1);

    Member member2 = new Member();
    member2.setName("Spring2");
    memberRepository.save(member2);

    Member result = memberRepository.findByName(member1.getName()).get();

    assertThat(member1).isEqualTo(result);
}

@Test
void findAll() {
    Member member1 = new Member();
    member1.setName("Spring1");
    memberRepository.save(member1);

    Member member2 = new Member();
    member2.setName("Spring2");
    memberRepository.save(member2);

    List<Member> memberList = memberRepository.findAll();

    assertThat(memberList.size()).isEqualTo(2);
}
```

- Optional값을 그냥 get()으로 가져오는것은 좋지 않다.
- 하지만 테스트 코드에서는 간편하게 이런식으로 사용해도 괜찮다.

### 회원 서비스 개발

- Repository는 기계적으로 네이밍해도 괜찮다.
- Service는 비즈니스에서 사용되는 용어를 사용하는것이 좋다.(비즈니스에 의존적으로 개발)

```java
public class MemberService {

    private final MemberRepository memberRepository;

    public MemberService(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }
}
```

- MemberService가 생성될때 외부에서 memberRepository를 주입받는다.

```java
public Long join(Member member() {
    validateDuplicateMember(member);
    memberRepository.save(member);
    return member.getId();
}
```

- 회원 가입에 성공할 경우 아이디 값을 반환(가상의 비즈니스 로직)

```java
private void validateDuplicateMember(Member member) {
    memberRepository.findByName(member.getName())
        .ifPresent(m -> {
            throw new IllegalStateException("이미 존재하는 회원입니다.");
        });
}
```

- 회원 이름이 같을 경우 가입이 불가(가상의 비즈니스 로직)
- Optional에서 어떠한 값이 null이 아닌 경우 throw를 생성한다.
- 회원 이름이 중복되는 경우 `IllegalStateException` 예외 발생

### 회원 서비스 테스트

```java
MemberService memberService;
MemoryMemberRepository memberRepository;

@BeforeEach
public void beforEach() {
    memberRepository = new MemoryMemberRepository();
    memberService = new MemberService(memberRepository);
}
```

- `@beforeEach` after의 반대 메서드가 실행 되기전 작동되게 만들어준다.
- 전역으로 객체를 생성해도 되지만, 여러곳에서 같이 쓰이는 객체를 여러곳에서 생성 할 경우 문제가 발생 될 수 있기 때문에 생성자를 통해 객체를 생성할 때 memberRepository를 주입해준다.
- 위의 방식이 바로 DI(Dependency injectio) 즉, 의존성 주입이다.

```java
@Test
void 중복_회원_예외() {
    //given
    Member member1 = new Member();
    member1.setName("spring");
    Member member2 = new Member();
    member2.setName("spring");

    //when
    memberService.join(member1);

    //then
    IllegalStateException e = assertThrows(IllegalStateException.class, () -> memberService.join(member2));
    assertThat(e.getMessage()).isEqualTo("이미 존재하는 회원입니다.");
}
```

- 테스트 메서드의 네이밍은 한글로 만들어도 상관없다.
- `//given //when //then` 으로 나누고 이걸 기반으로 작성해보는 연습을 하고, 추후 상황에 따라 변경해보자.
- 해당 로직을 진행 했을 때 원하는 예외가 발생하는지 알아보는 테스트 코드
