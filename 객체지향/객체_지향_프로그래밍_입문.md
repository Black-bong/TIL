# 객체 지향 프로그래밍 입문

---

> 인프런에서 최범균님의 객체 지향 프로그래밍 입문 강의를 보고 요약, 정리한 글입니다.
>
>
> `강의 내용외에 직접 검색하고, 찾아본 내용도 함께 작성될 수 있습니다.`
>
> > 출처: <a href = https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8/dashboard>객체 지향 프로그래밍 입문 강의</a>
> >

---

## 0. 들어가기 전에
- 시간이 점차 지남에따라 코드 한줄을 작성하는 시간이 점점 늘어나는 이유가 뭘까?
  - 코드 분석 시간 증가
    - 비즈니스 요구사항이 변경됨에 따라 코드를 변경해야하는데 그 변경을 위해 코드를 분석하는 시간이 길어진다면?
  - 코드 변경 시간 증가
    - 분석 시간이 길어지니 자연스럽게 변경 시간도 함께 길어질 수 밖에 없다.
- 소프트웨어의 가치: 얼마나 잘 변화할 수 있냐
  - 시간이 지남에 따라 변화하는 시간이 점점 늘어나고 어려워진다면 과연 소프트웨어의 가치는 잘 지켜지고 있는건가?

> Jessica Kerr: Software maintenance is not "keep it working like before." it is "keep being useful is a changing world"
> 
> 소프트웨어 유지보수는 "이전 처럼 계속 작동하게 하는 것"이 아니라 "계속 유용하게 사용하는것"입니다.

- 우리가 사용하고 있는 소프트웨어가 변화하지(업데이트가 없다면) 않는다면 그게 살아있는 소프트웨어라 할 수 있을까?
- 소프트웨어를 변화시키는데 비용이 많이 발생한다면 -> 자주 변화하기가 어렵다 -> 다른 소프트웨어와 경쟁력에서 뒤쳐진다 -> 망한다.
- 우리는 낮은 비용으로 소프트웨어를 변화할 수 있게 해야한다.
- 이를 위한 방법 중 하나가 객체 지향이다.
- 그 외에도 함수형, 리액티브 등등 다양한 방법이 있다.
- 객체 지향은 캡슐화 + 다형성(추상화)를 활용해 변경에 들어가는 비용을 낮춰준다.

## 1. 객체
### 객체
- 절차 지향: 하나의 데이터를 여러 프로시저가 공유하는 방식
  - 처음 프로그래밍을 시작하면 대부분 이 방식으로 코드를 작성한다.
  - 시간이 지남에 따라 구조를 복잡하게 만든다. -> 수정이 어렵다.
- 객체 지향: 데이터와 프로시저를 객체 단위로 묶고 특정 객체가 가지고 있는 데이터는 그 객체의 프로시저만 접근 가능
  - 처음에는 어렵다.
  - 시간이 지남에 따라 변경이 수월해진다.
  - 객체의 핵심: 기능 제공
    - 객체는 제공하는 기능으로 정의, 내부적으로 가진 필드(데이터)로 정의하지 않는다.
- 기능 명세: 메서드를 이용해서 기능 명세
    ```java
    public class VolumeController {
        public void increase(int inc) {
            ...
        }
        
        public void decrease(int dec) {
            ...
        }

        public int volume() {
            ...
        }
    }
    ```
    - 이름, 파라미터, 결과로 구성

- 객체와 객체는 기능을 사용해서 연결
    ```java
    VolumnController volCont = new VolumnController();

    volCont.increase(4);

    volCont.decrease(3);

    int currentVol = volCont.volume();
    ```
    - 기능 사용 = 메서드 호출

- 객체?
  ```java
  public class Member {
      private String name;
      private String id;

      public void setName(String name) {
          this.name = name;
      }

      public void setId(String id) {
          this.id = id;
      }

      public String getName() {
          return name;
      }

      public String getId() {
          return id;
      }
  }
  ```
  - 이게 과연 객체일까?
    - 나는 객체라고 생각했는데!!
    - 별 다른 기능이 없기 때문에(get, set은 데이터에 직접 접근하는거랑 다를게 없다.) 이건 그냥 데이터 클래스다.
  - 여기에 특별한 기능이 추가된다면 그때부터 이건 객체가 된다.
  - 객체는 `기능`으로 정의한다.

### 캡슐화
- 캡슐화만 잘해도 좋은 코드를 만들 가능성이 높아진다.
- 캡슐화: 단순하게 데이터와 데이터와 관련된 기능을 묶는것
- 캡슐화는 연쇄적인 변경 전파를 최소화
- 객체가 기능을 어떻게 구현했는지 외부에 감추는 것
  - 구현에 사용된 데이터의 상세 내용을 외부에 감춤(Information Hiding 정보 은닉)
  - 예전에는 정보 은닉과 캡슐화를 구분해서 정의했지만, 최근에는 캡술화 속에 정보 은식을 포함해서 표현하는 것이 추세
- 캡슐화의 이유: 외부에 영향없이 객체 내부 구현을 변경할 수 있다.

```java
if (acc.getMemberShip() == REGULAR && acc.getExpDate().isAfter(now())) {
    정회원 기능
}
```
- 이런 회원 등급에 사용 가능 기능이 구분되는 비즈니스 요구사항이 있다고 했을때
- 5년 뒤 특별 이벤트로 5년 이상 사용자에 대해 일부 기능을 사용할 수 있는 정회원 혜택을 1개월 무상 제공해준다 했을때 코드를 어떻게 변경할 것인가?
```java
if (acc.getMemberShip() == REGULAR &&
    (
        (acc.getServiceDate().isAfter(fiveYearAgo) && 
        acc.getExpDate().isAfter(now())) ||
        (acc.getServiceDate().isBefore(fiveYearAgo) && 
        addMonth(acc.getExpDate()).isAfter(now()))
    )
)
```
- 캡슐화 하지 않은 코드
- 이런 코드를 한곳이 아닌 여러 군데 찾아서 변경해야한다면 시간이 너무 낭비된다.
- 요구사항의 변화가 데이터 구조/사용에 변화를 발생시킨다.
- 데이터를 사용하는 코드의 수정이 발생

```java
if (acc.hasRegularPerMission()) {
    정회원 기능
}
```
- 위에 있는 코드와 같은 기능을 하는 코드
```java
public class Account {
    private Membership membership;
    private Date expDate;

    public boolean hasRegularPermission() {
        return membership == REGULAR &&
                expDate.isAfter(now())
    }
}
```
- 기능을 제공하고 구현 상세를 감춤
- 캡슐화한 코드
```java
public class Account {
    private Membership membership;
    private Date expDate;

    public boolean hasRegularPermission() {
        return membership == REGULAR &&
                (expDate.isAfter(now()) ||
                    (
                        serviceDate.isBefore(fiveYearAgo()) &&
                        addMonth(expDate).isAfter(now())
                    )
                );
    }
}
```
- 똑같이 5년 이상 고객에게 혜택을 주는 코드로 변경
- 요구사항이 변경되도 내부 구현만 변경 할 뿐 사용하는 코드에 변경은 없다.
- 캡슐화된 기능을 사용하는 코드에 영향을 최소화한다.
- 캡슐화 시도 -> 기능에 대한(의도) 이해를 높인다.

### 캡술화를 위한 규칙
- Tell, Don`t Ask(TDA 원칙)
  - 데이터를 달라 하지말고 해달라고 하기
    ```java
    if (acc.getMembership() == REGULAR) {
        정회원 기능
    }

    // 이렇게 사용
    if (acc.hasRegularPermission()) {
        정회원 기능
    }
    ```
  - 데이터를 `get`하지말고(데이터 그대로 가져와서 사용하지 말고) 데이터를 확인하는 기능을 가진 메소드에게 확인하고 알려 달라고 하기
  - 호눅스가 `get`, `set`을 사용하지 말고, 메소드를 활용해야 한다고 한거랑 비슷한 맥락인거 같다. 그때 당시는 이해하지 못했는데
- Demeter`s Law(디미터 법칙)
  - 메서드에서 생성한 객체의 메서드만 호출
  - 파라미터로 받은 객체의 메서드만 호출
  - 필드로 참조하는 객체의 메서드만 호출
    ```java
    acc.getExpDate().isAfter(now)

    Date dat = acc.getExpDate();
    date.isAfter(now);

    // 이렇게 사용
    acc.isExpired();

    acc.isValid(now);
    ```
  - 연속해서 메소드를 부르는걸 메소드 하나만 호출하도록 변경
  - `왜?` 이걸 이렇게 쓰는지(acc에서 getExpDate()를 꺼낸 후 왜 다시 isAfter(now)를 하는건지) 생각해보고 의도를 파악하는게 중요하다.

### 캡슐화 예제
- 캡슐화 연습 1
    ```java
    public AuthResult authenticate(String id, String pw) {
        Member mem = findOne(id);
        if (mem == null) return AuthResult.NO_MATCH;

        if (mem.getVerificationEmailStatus() != 2) {
            return AuthResult.NO_EMAIL_VERIFIED;
        }
        if (passwordEncoder.isPasswordValid(mem.getPassword(), pw, mem.getId())) {
            return AuthResult.SUCCESS;
        }
        return AuthResult.NO_MATCH;
    }
    ```
    - Tell, Dont`Ask를 활용해보자.
    ```java
    if (!mem.isEmailVerified()) {
        return AuthResult.NO_EMAIL_VERIFIED;
    }
    ```
    - 데이터를 가져와서 판단하지 말고, 판단해달라고 요청
    ```java
    public class Member {
        private int verificationEmailStatus;

        public boolean isEmailVerified() {
            return verificationEmailStatus == 2;
        }
    }
    ```
    - `Member`객체에 이메일 상태를 검증하는 메서드를 활용

- 캡슐화 연습 2
  > 출처: 리펙토링(마틴 파울러 저) 책에서 코드를 발췌
    ```java
    public class Member {
        public static int REGULAR = 0;
        public static int NEW_RELEASE = 1;
        private int priceCode;

        public int getPriceCode() {
            return priceCode;
        }
        ...
    }
    ```
    - `Member`클래스 코드
    ```java
    public class Rental {
        private Movie movie;
        private int daysRented;

        public int getFrequentRenterPoints() {
            if (movie.getPriceCode() == Movie.NEW_RELEASE &&
                daysRented > 1)
                return 2;
            else
                return 1;
        }
    }
    ```
    - Tall Don`t Ask를 활용하자
    ```java
    public class Member {
        public static int REGULAR = 0;
        public static int NEW_RELEASE = 1;
        private int priceCode;

        public int getFrequentRenterPoints(int daysRented) {
            if (priceCode == NEW_RELESE &&
                daysRented > 1)
                return 2;
            else
                return 1;
        }
    }
    ...
    ```
    - 변경된 `Member`클래스 코드
    - point를 구분하는 로직을 메소드화하여 `Member` 객체에 기능으로 추가
    ```java
    public class Rental {
        private Movie movie;
        private int daysRented;

        public int getFrequentRenterPoints() {
            return movie.getFrequendRenterPoints(daysRented);
        }
        ...
    }
    ```
    - 데이터를 가져와서 비교하는것이 아니라 비교에 필요한 데이터(daysRented)를 보내고 비교해달라고 요청
    - 비즈니스 요구사항에 따라 point 지급에 변경이 생기면, `getFrequentRenterPoints()`메서드를 사용하는 곳의 코드는 변경 할 필요없이 `getFrequentRenterPoints()`이 메서드만 변경하면 된다.

- 캡슐화 연습 3
    ```java
    Timer t = new Timer();
    t.startTime = System.currentTimeMillis();
    
    ...

    t.stopTime = System.currentTimeMillis();

    long elaspedTime = t.stopTime - t.startTime;
    ```
    - 전형적인 절차지향적 코드(여러곳에서 같은 데이터를 사용)
    ```java
    public class Timer {
        public long startTime;
        public long stopTime;

    }
    ```
    - 디미터 법칙을 활용해 보자.
    ```java
    Timer t = new Timer();
    t.start();

    ...

    t.stop();

    long elaspendTime = t.elapsedTime(MILLISECOND);
    ```
    - 여러곳에서 데이터를 사용하던 것을 메서드만 호출하는 식으로 변경
    - 어떻게 구현하고, 어떤 데이터를 사용했는지는 알 수 없고 그저 기능만 가져다 사용하게 된다.
    ```java
    public class Timer {
        private long startTime;
        private long stopTime;

        public void start() {
            this.startTime = System.currentTimeMillis();
        }
        public void stop() {
            this.stopTime = System.currentTimeMillis();
        }
        public long elapsedTime(TimeUnit unit) {
            switch (unit) {
                case MILLISECOND:
                    return stopTime - startTime;
                ...
            }
        }
    }
    ```
    - `Timer`객체에 타이머를 시작하는 메소드와 중지하는 메소드 그리고 시간을 반환해 주는 메소드 이렇게 3가지의 기능을 가지는 메소드를 각각 생성
    - 추후 MILLISECOND가 NANOSECOND로 변경되더라도 최소한의 수정으로 변경이 가능하다.

- 캡술화 연습 4
    ```java
    public void verifyEmail(String token) {
        Member mem = findByToken(token);
        if (men == null) throw new BadTokenException();

        if (mem.getVerificationEmailStatus() == 2) {
            throw new AlreadyVerifiedException();
        } else {
            mem.setVerificationEmailStatus(2);
        }
        ...
    }
    ```
    - 데이터를 가져오고 판단한 후 데이터를 변경하는 패턴의 코드
    - 이런 경우는 어떻게 캡슐화를 해야할까?
    ```java
    public void verifyEmail(String token) {
        Member mem = findByToken(token);
        
        mem.verifyEmail();
        ...
    }
    ```
    - 데이터를 가져오고 수정하는 로직을 통으로 캡슐화하는 것이 좋다.
    ```java
    public class Member {
        private int verificationEmailStatus;
    
        public void verifyEmail() {
            if (isEmailVerified()) 
                throw new AlreadVerifiedException();
            else 
                this.verificationEmailStatus = 2;
        }

        public boolean isEmailVerified() {
            return verificationEmailStatus = 2;
        }
    }
    ```
    - 데이터를 가져오고, 판단하고, 변경하는 이런 코드는 이런식의 캡슐화도 좋은 방법이다.